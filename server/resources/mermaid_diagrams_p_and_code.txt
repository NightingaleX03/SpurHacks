---  Page (https://mermaid.js.org/syntax/flowchart.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
Flowcharts are composed of nodes (geometric shapes) and edges (arrows or lines). The Mermaid code defines how nodes and edges are made and accommodates different arrow types, multi-directional arrows, and any linking to and from subgraphs.

[Paragraph]
WARNING

[Paragraph]
If you are using the word "end" in a Flowchart node, capitalize the entire word or any of the letters (e.g., "End" or "END"), or apply this workaround. Typing "end" in all lowercase letters will break the Flowchart.

[Paragraph]
WARNING

[Paragraph]
If you are using the letter "o" or "x" as the first letter in a connecting Flowchart node, add a space before the letter or capitalize the letter (e.g., "dev--- ops", "dev---Ops").

[Paragraph]
Typing "A---oB" will create a circle edge.

[Paragraph]
Typing "A---xB" will create a cross edge.

[Code]
---
title: Node
---
flowchart LR
    id

[Paragraph]
id

[Paragraph]
INFO

[Paragraph]
The id is what is displayed in the box.

[Paragraph]
TIP

[Paragraph]
Instead of flowchart one can also use graph.

[Code]
flowchart

[Code]
graph

[Paragraph]
It is also possible to set text in the box that differs from the id. If this is done several times, it is the last text found for the node that will be used. Also if you define edges for the node later on, you can omit text definitions. The one previously defined will be used when rendering the box.

[Code]
---
title: Node with text
---
flowchart LR
    id1[This is the text in the box]

[Paragraph]
This is the text in the box

[Paragraph]
Use " to enclose the unicode text.

[Code]
"

[Code]
flowchart LR
    id["This ❤ Unicode"]

[Paragraph]
This ❤ Unicode

[Paragraph]
Use double quotes and backticks "` text `" to enclose the markdown text.

[Code]
---
config:
  flowchart:
    htmlLabels: false
---
flowchart LR
    markdown["`This **is** _Markdown_`"]
    newLines["`Line1
    Line 2
    Line 3`"]
    markdown --> newLines

[Paragraph]
This is Markdown

[Paragraph]
Line1
Line 2
Line 3

[Paragraph]
This statement declares the direction of the Flowchart.

[Paragraph]
This declares the flowchart is oriented from top to bottom (TD or TB).

[Code]
TD

[Code]
TB

[Code]
flowchart TD
    Start --> Stop

[Paragraph]
Start

[Paragraph]
Stop

[Paragraph]
This declares the flowchart is oriented from left to right (LR).

[Code]
LR

[Code]
flowchart LR
    Start --> Stop

[Paragraph]
Start

[Paragraph]
Stop

[Paragraph]
Possible FlowChart orientations are:

[Code]
flowchart LR
    id1(This is the text in the box)

[Paragraph]
This is the text in the box

[Code]
flowchart LR
    id1([This is the text in the box])

[Paragraph]
This is the text in the box

[Code]
flowchart LR
    id1[[This is the text in the box]]

[Paragraph]
This is the text in the box

[Code]
flowchart LR
    id1[(Database)]

[Code]
flowchart LR
    id1((This is the text in the circle))

[Code]
flowchart LR
    id1>This is the text in the box]

[Paragraph]
Currently only the shape above is possible and not its mirror. This might change with future releases.

[Code]
flowchart LR
    id1{This is the text in the box}

[Code]
flowchart LR
    id1{{This is the text in the box}}

[Code]
flowchart TD
    id1[/This is the text in the box/]

[Code]
flowchart TD
    id1[\This is the text in the box\]

[Code]
flowchart TD
    A[/Christmas\]

[Code]
flowchart TD
    B[\Go shopping/]

[Code]
flowchart TD
    id1(((This is the text in the circle)))

[Paragraph]
Mermaid introduces 30 new shapes to enhance the flexibility and precision of flowchart creation. These new shapes provide more options to represent processes, decisions, events, data storage visually, and other elements within your flowcharts, improving clarity and semantic meaning.

[Paragraph]
New Syntax for Shape Definition

[Paragraph]
Mermaid now supports a general syntax for defining shape types to accommodate the growing number of shapes. This syntax allows you to assign specific shapes to nodes using a clear and flexible format:

[Code]
A@{ shape: rect }

[Paragraph]
This syntax creates a node A as a rectangle. It renders in the same way as A["A"], or A.

[Code]
A["A"]

[Code]
A

[Paragraph]
Below is a comprehensive list of the newly introduced shapes and their corresponding semantic meanings, short names, and aliases:

[Code]
notch-rect

[Code]
card

[Code]
notched-rectangle

[Code]
hourglass

[Code]
collate

[Code]
hourglass

[Code]
bolt

[Code]
com-link

[Code]
lightning-bolt

[Code]
brace

[Code]
brace-l

[Code]
comment

[Code]
brace-r

[Code]
braces

[Code]
lean-r

[Code]
in-out

[Code]
lean-right

[Code]
lean-l

[Code]
lean-left

[Code]
out-in

[Code]
cyl

[Code]
cylinder

[Code]
database

[Code]
db

[Code]
diam

[Code]
decision

[Code]
diamond

[Code]
question

[Code]
delay

[Code]
half-rounded-rectangle

[Code]
h-cyl

[Code]
das

[Code]
horizontal-cylinder

[Code]
lin-cyl

[Code]
disk

[Code]
lined-cylinder

[Code]
curv-trap

[Code]
curved-trapezoid

[Code]
display

[Code]
div-rect

[Code]
div-proc

[Code]
divided-process

[Code]
divided-rectangle

[Code]
doc

[Code]
doc

[Code]
document

[Code]
rounded

[Code]
event

[Code]
tri

[Code]
extract

[Code]
triangle

[Code]
fork

[Code]
join

[Code]
win-pane

[Code]
internal-storage

[Code]
window-pane

[Code]
f-circ

[Code]
filled-circle

[Code]
junction

[Code]
lin-doc

[Code]
lined-document

[Code]
lin-rect

[Code]
lin-proc

[Code]
lined-process

[Code]
lined-rectangle

[Code]
shaded-process

[Code]
notch-pent

[Code]
loop-limit

[Code]
notched-pentagon

[Code]
flip-tri

[Code]
flipped-triangle

[Code]
manual-file

[Code]
sl-rect

[Code]
manual-input

[Code]
sloped-rectangle

[Code]
trap-t

[Code]
inv-trapezoid

[Code]
manual

[Code]
trapezoid-top

[Code]
docs

[Code]
documents

[Code]
st-doc

[Code]
stacked-document

[Code]
st-rect

[Code]
processes

[Code]
procs

[Code]
stacked-rectangle

[Code]
odd

[Code]
flag

[Code]
paper-tape

[Code]
hex

[Code]
hexagon

[Code]
prepare

[Code]
trap-b

[Code]
priority

[Code]
trapezoid

[Code]
trapezoid-bottom

[Code]
rect

[Code]
proc

[Code]
process

[Code]
rectangle

[Code]
circle

[Code]
circ

[Code]
sm-circ

[Code]
small-circle

[Code]
start

[Code]
dbl-circ

[Code]
double-circle

[Code]
fr-circ

[Code]
framed-circle

[Code]
stop

[Code]
bow-rect

[Code]
bow-tie-rectangle

[Code]
stored-data

[Code]
fr-rect

[Code]
framed-rectangle

[Code]
subproc

[Code]
subprocess

[Code]
subroutine

[Code]
cross-circ

[Code]
crossed-circle

[Code]
summary

[Code]
tag-doc

[Code]
tag-doc

[Code]
tagged-document

[Code]
tag-rect

[Code]
tag-proc

[Code]
tagged-process

[Code]
tagged-rectangle

[Code]
stadium

[Code]
pill

[Code]
terminal

[Code]
text

[Paragraph]
Here’s an example flowchart that utilizes some of the newly introduced shapes:

[Code]
flowchart RL
    A@{ shape: manual-file, label: "File Handling"}
    B@{ shape: manual-input, label: "User Input"}
    C@{ shape: docs, label: "Multiple Documents"}
    D@{ shape: procs, label: "Process Automation"}
    E@{ shape: paper-tape, label: "Paper Records"}

[Code]
flowchart TD
    A@{ shape: rect, label: "This is a process" }

[Code]
flowchart TD
    A@{ shape: rounded, label: "This is an event" }

[Code]
flowchart TD
    A@{ shape: stadium, label: "Terminal point" }

[Code]
flowchart TD
    A@{ shape: subproc, label: "This is a subprocess" }

[Code]
flowchart TD
    A@{ shape: cyl, label: "Database" }

[Code]
flowchart TD
    A@{ shape: circle, label: "Start" }

[Code]
flowchart TD
    A@{ shape: odd, label: "Odd shape" }

[Code]
flowchart TD
    A@{ shape: diamond, label: "Decision" }

[Code]
flowchart TD
    A@{ shape: hex, label: "Prepare conditional" }

[Code]
flowchart TD
    A@{ shape: lean-r, label: "Input/Output" }

[Code]
flowchart TD
    A@{ shape: lean-l, label: "Output/Input" }

[Code]
flowchart TD
    A@{ shape: trap-b, label: "Priority action" }

[Code]
flowchart TD
    A@{ shape: trap-t, label: "Manual operation" }

[Code]
flowchart TD
    A@{ shape: dbl-circ, label: "Stop" }

[Code]
flowchart TD
    A@{ shape: text, label: "This is a text block" }

[Code]
flowchart TD
    A@{ shape: notch-rect, label: "Card" }

[Code]
flowchart TD
    A@{ shape: lin-rect, label: "Lined process" }

[Code]
flowchart TD
    A@{ shape: sm-circ, label: "Small start" }

[Code]
flowchart TD
    A@{ shape: framed-circle, label: "Stop" }

[Code]
flowchart TD
    A@{ shape: fork, label: "Fork or Join" }

[Code]
flowchart TD
    A@{ shape: hourglass, label: "Collate" }

[Code]
flowchart TD
    A@{ shape: comment, label: "Comment" }

[Code]
flowchart TD
    A@{ shape: brace-r, label: "Comment" }

[Code]
flowchart TD
    A@{ shape: braces, label: "Comment" }

[Code]
flowchart TD
    A@{ shape: bolt, label: "Communication link" }

[Code]
flowchart TD
    A@{ shape: doc, label: "Document" }

[Code]
flowchart TD
    A@{ shape: delay, label: "Delay" }

[Code]
flowchart TD
    A@{ shape: das, label: "Direct access storage" }

[Code]
flowchart TD
    A@{ shape: lin-cyl, label: "Disk storage" }

[Code]
flowchart TD
    A@{ shape: curv-trap, label: "Display" }

[Code]
flowchart TD
    A@{ shape: div-rect, label: "Divided process" }

[Code]
flowchart TD
    A@{ shape: tri, label: "Extract" }

[Code]
flowchart TD
    A@{ shape: win-pane, label: "Internal storage" }

[Code]
flowchart TD
    A@{ shape: f-circ, label: "Junction" }

[Code]
flowchart TD
    A@{ shape: lin-doc, label: "Lined document" }

[Code]
flowchart TD
    A@{ shape: notch-pent, label: "Loop limit" }

[Code]
flowchart TD
    A@{ shape: flip-tri, label: "Manual file" }

[Code]
flowchart TD
    A@{ shape: sl-rect, label: "Manual input" }

[Code]
flowchart TD
    A@{ shape: docs, label: "Multiple documents" }

[Code]
flowchart TD
    A@{ shape: processes, label: "Multiple processes" }

[Code]
flowchart TD
    A@{ shape: flag, label: "Paper tape" }

[Code]
flowchart TD
    A@{ shape: bow-rect, label: "Stored data" }

[Code]
flowchart TD
    A@{ shape: cross-circ, label: "Summary" }

[Code]
flowchart TD
    A@{ shape: tag-doc, label: "Tagged document" }

[Code]
flowchart TD
    A@{ shape: tag-rect, label: "Tagged process" }

[Paragraph]
Mermaid also introduces 2 special shapes to enhance your flowcharts: icon and image. These shapes allow you to include icons and images directly within your flowcharts, providing more visual context and clarity.

[Paragraph]
You can use the icon shape to include an icon in your flowchart. To use icons, you need to register the icon pack first. Follow the instructions to add custom icons. The syntax for defining an icon shape is as follows:

[Code]
icon

[Code]
flowchart TD
    A@{ icon: "fa:user", form: "square", label: "User Icon", pos: "t", h: 60 }

[Code]
square

[Code]
circle

[Code]
rounded

[Code]
t

[Code]
b

[Paragraph]
You can use the image shape to include an image in your flowchart. The syntax for defining an image shape is as follows:

[Code]
image

[Code]
flowchart TD
    A@{ img: "https://example.com/image.png", label: "Image Label", pos: "t", w: 60, h: 60, constraint: "off" }

[Code]
t

[Code]
b

[Code]
h

[Code]
w

[Code]
off

[Code]
on

[Code]
off

[Paragraph]
These new shapes provide additional flexibility and visual appeal to your flowcharts, making them more informative and engaging.

[Paragraph]
Nodes can be connected with links/edges. It is possible to have different types of links or attach a text string to a link.

[Code]
flowchart LR
    A-->B

[Code]
flowchart LR
    A --- B

[Code]
flowchart LR
    A-- This is the text! ---B

[Paragraph]
or

[Code]
flowchart LR
    A---|This is the text|B

[Code]
flowchart LR
    A-->|text|B

[Paragraph]
or

[Code]
flowchart LR
    A-- text -->B

[Code]
flowchart LR
   A-.->B;

[Code]
flowchart LR
   A-. text .-> B

[Code]
flowchart LR
   A ==> B

[Code]
flowchart LR
   A == text ==> B

[Paragraph]
This can be a useful tool in some instances where you want to alter the default positioning of a node.

[Code]
flowchart LR
    A ~~~ B

[Paragraph]
It is possible declare many links in the same line as per below:

[Code]
flowchart LR
   A -- text --> B -- text2 --> C

[Paragraph]
It is also possible to declare multiple nodes links in the same line as per below:

[Code]
flowchart LR
   a --> b & c--> d

[Paragraph]
You can then describe dependencies in a very expressive way. Like the one-liner below:

[Code]
flowchart TB
    A & B--> C & D

[Paragraph]
If you describe the same diagram using the basic syntax, it will take four lines. A word of warning, one could go overboard with this making the flowchart harder to read in markdown form. The Swedish word lagom comes to mind. It means, not too much and not too little. This goes for expressive syntaxes as well.

[Code]
lagom

[Code]
flowchart TB
    A --> C
    A --> D
    B --> C
    B --> D

[Paragraph]
Mermaid now supports assigning IDs to edges, similar to how IDs and metadata can be attached to nodes. This feature lays the groundwork for more advanced styling, classes, and animation capabilities on edges.

[Paragraph]
Syntax:

[Paragraph]
To give an edge an ID, prepend the edge syntax with the ID followed by an @ character. For example:

[Code]
@

[Code]
flowchart LR
  A e1@--> B

[Paragraph]
In this example, e1 is the ID of the edge connecting A to B. You can then use this ID in later definitions or style statements, just like with nodes.

[Code]
e1

[Code]
A

[Code]
B

[Paragraph]
Once you have assigned an ID to an edge, you can turn on animations for that edge by defining the edge’s properties:

[Code]
flowchart LR
  A e1@==> B
  e1@{ animate: true }

[Paragraph]
This tells Mermaid that the edge e1 should be animated.

[Code]
e1

[Paragraph]
In the initial version, two animation speeds are supported: fast and slow. Selecting a specific animation type is a shorthand for enabling animation and setting the animation speed in one go.

[Code]
fast

[Code]
slow

[Paragraph]
Examples:

[Code]
flowchart LR
  A e1@--> B
  e1@{ animation: fast }

[Paragraph]
This is equivalent to { animate: true, animation: fast }.

[Code]
{ animate: true, animation: fast }

[Paragraph]
You can also animate edges by assigning a class to them and then defining animation properties in a classDef statement. For example:

[Code]
classDef

[Code]
flowchart LR
  A e1@--> B
  classDef animate stroke-dasharray: 9,5,stroke-dashoffset: 900,animation: dash 25s linear infinite;
  class e1 animate

[Paragraph]
In this snippet:

[Code]
e1@-->

[Code]
e1

[Code]
classDef animate

[Code]
animate

[Code]
class e1 animate

[Code]
animate

[Code]
e1

[Paragraph]
Note on Escaping Commas: When setting the stroke-dasharray property, remember to escape commas as \, since commas are used as delimiters in Mermaid’s style definitions.

[Code]
stroke-dasharray

[Code]
\,

[Paragraph]
There are new types of arrows supported:

[Code]
flowchart LR
    A --o B

[Code]
flowchart LR
    A --x B

[Paragraph]
There is the possibility to use multidirectional arrows.

[Code]
flowchart LR
    A o--o B
    B <--> C
    C x--x D

[Paragraph]
Each node in the flowchart is ultimately assigned to a rank in the rendered graph, i.e. to a vertical or horizontal level (depending on the flowchart orientation), based on the nodes to which it is linked. By default, links can span any number of ranks, but you can ask for any link to be longer than the others by adding extra dashes in the link definition.

[Paragraph]
In the following example, two extra dashes are added in the link from node B to node E, so that it spans two more ranks than regular links:

[Code]
flowchart TD
    A[Start] --> B{Is it?}
    B -->|Yes| C[OK]
    C --> D[Rethink]
    D --> B
    B ---->|No| E[End]

[Paragraph]
Note Links may still be made longer than the requested number of ranks by the rendering engine to accommodate other requests.

[Paragraph]
When the link label is written in the middle of the link, the extra dashes must be added on the right side of the link. The following example is equivalent to the previous one:

[Code]
flowchart TD
    A[Start] --> B{Is it?}
    B -- Yes --> C[OK]
    C --> D[Rethink]
    D --> B
    B -- No ----> E[End]

[Paragraph]
For dotted or thick links, the characters to add are equals signs or dots, as summed up in the following table:

[Code]
---

[Code]
----

[Code]
-----

[Code]
-->

[Code]
--->

[Code]
---->

[Code]
===

[Code]
====

[Code]
=====

[Code]
==>

[Code]
===>

[Code]
====>

[Code]
-.-

[Code]
-..-

[Code]
-...-

[Code]
-.->

[Code]
-..->

[Code]
-...->

[Paragraph]
It is possible to put text within quotes in order to render more troublesome characters. As in the example below:

[Code]
flowchart LR
    id1["This is the (text) in the box"]

[Paragraph]
It is possible to escape characters using the syntax exemplified here.

[Code]
flowchart LR
        A["A double quote:#quot;"] --> B["A dec char:#9829;"]

[Paragraph]
Numbers given are base 10, so # can be encoded as #35;. It is also supported to use HTML character names.

[Code]
#

[Code]
#35;

[Code]
subgraph title
    graph definition
end

[Paragraph]
An example below:

[Code]
flowchart TB
    c1-->a2
    subgraph one
    a1-->a2
    end
    subgraph two
    b1-->b2
    end
    subgraph three
    c1-->c2
    end

[Paragraph]
You can also set an explicit id for the subgraph.

[Code]
flowchart TB
    c1-->a2
    subgraph ide1 [one]
    a1-->a2
    end

[Paragraph]
With the graphtype flowchart it is also possible to set edges to and from subgraphs as in the flowchart below.

[Code]
flowchart TB
    c1-->a2
    subgraph one
    a1-->a2
    end
    subgraph two
    b1-->b2
    end
    subgraph three
    c1-->c2
    end
    one --> two
    three --> two
    two --> c2

[Paragraph]
With the graphtype flowcharts you can use the direction statement to set the direction which the subgraph will render like in this example.

[Code]
flowchart LR
  subgraph TOP
    direction TB
    subgraph B1
        direction RL
        i1 -->f1
    end
    subgraph B2
        direction BT
        i2 -->f2
    end
  end
  A --> TOP --> B
  B1 --> B2

[Paragraph]
If any of a subgraph's nodes are linked to the outside, subgraph direction will be ignored. Instead the subgraph will inherit the direction of the parent graph:

[Code]
flowchart LR
    subgraph subgraph1
        direction TB
        top1[top] --> bottom1[bottom]
    end
    subgraph subgraph2
        direction TB
        top2[top] --> bottom2[bottom]
    end
    %% ^ These subgraphs are identical, except for the links to them:

    %% Link *to* subgraph1: subgraph1 direction is maintained
    outside --> subgraph1
    %% Link *within* subgraph2:
    %% subgraph2 inherits the direction of the top-level graph (LR)
    outside ---> top2

[Paragraph]
The "Markdown Strings" feature enhances flowcharts and mind maps by offering a more versatile string type, which supports text formatting options such as bold and italics, and automatically wraps text within labels.

[Code]
---
config:
  flowchart:
    htmlLabels: false
---
flowchart LR
subgraph "One"
  a("`The **cat**
  in the hat`") -- "edge label" --> b{{"`The **dog** in the hog`"}}
end
subgraph "`**Two**`"
  c("`The **cat**
  in the hat`") -- "`Bold **edge label**`" --> d("The dog in the hog")
end

[Paragraph]
Formatting:

[Code]
**

[Code]
*

[Code]
<br>

[Code]
<br>

[Paragraph]
This feature is applicable to node labels, edge labels, and subgraph labels.

[Paragraph]
The auto wrapping can be disabled by using

[Code]
---
config:
  markdownAutoWrap: false
---
graph LR

[Paragraph]
It is possible to bind a click event to a node, the click can lead to either a javascript callback or to a link which will be opened in a new browser tab.

[Paragraph]
INFO

[Paragraph]
This functionality is disabled when using securityLevel='strict' and enabled when using securityLevel='loose'.

[Code]
securityLevel='strict'

[Code]
securityLevel='loose'

[Code]
click nodeId callback
click nodeId call callback()

[Paragraph]
Examples of tooltip usage below:

[Code]
<script>
  window.callback = function () {
    alert('A callback was triggered');
  };
</script>

[Paragraph]
The tooltip text is surrounded in double quotes. The styles of the tooltip are set by the class .mermaidTooltip.

[Code]
.mermaidTooltip

[Code]
flowchart LR
    A-->B
    B-->C
    C-->D
    click A callback "Tooltip for a callback"
    click B "https://www.github.com" "This is a tooltip for a link"
    click C call callback() "Tooltip for a callback"
    click D href "https://www.github.com" "This is a tooltip for a link"

[Paragraph]
Success The tooltip functionality and the ability to link to urls are available from version 0.5.2.

[Paragraph]
?> Due to limitations with how Docsify handles JavaScript callback functions, an alternate working demo for the above code can be viewed at this jsfiddle.

[Paragraph]
Links are opened in the same browser tab/window by default. It is possible to change this by adding a link target to the click definition (_self, _blank, _parent and _top are supported):

[Code]
_self

[Code]
_blank

[Code]
_parent

[Code]
_top

[Code]
flowchart LR
    A-->B
    B-->C
    C-->D
    D-->E
    click A "https://www.github.com" _blank
    click B "https://www.github.com" "Open this in a new tab" _blank
    click C href "https://www.github.com" _blank
    click D href "https://www.github.com" "Open this in a new tab" _blank

[Paragraph]
Beginner's tip—a full example using interactive links in a html context:

[Code]
<body>
  <pre class="mermaid">
    flowchart LR
        A-->B
        B-->C
        C-->D
        click A callback "Tooltip"
        click B "https://www.github.com" "This is a link"
        click C call callback() "Tooltip"
        click D href "https://www.github.com" "This is a link"
  </pre>

  <script>
    window.callback = function () {
      alert('A callback was triggered');
    };
    const config = {
      startOnLoad: true,
      flowchart: { useMaxWidth: true, htmlLabels: true, curve: 'cardinal' },
      securityLevel: 'loose',
    };
    mermaid.initialize(config);
  </script>
</body>

[Paragraph]
Comments can be entered within a flow diagram, which will be ignored by the parser. Comments need to be on their own line, and must be prefaced with %% (double percent signs). Any text after the start of the comment to the next newline will be treated as a comment, including any flow syntax

[Code]
%%

[Code]
flowchart LR
%% this is a comment A -- text --> B{node}
   A -- text --> B -- text2 --> C

[Paragraph]
It is possible to style links. For instance, you might want to style a link that is going backwards in the flow. As links have no ids in the same way as nodes, some other way of deciding what style the links should be attached to is required. Instead of ids, the order number of when the link was defined in the graph is used, or use default to apply to all links. In the example below the style defined in the linkStyle statement will belong to the fourth link in the graph:

[Code]
linkStyle 3 stroke:#ff3,stroke-width:4px,color:red;

[Paragraph]
It is also possible to add style to multiple links in a single statement, by separating link numbers with commas:

[Code]
linkStyle 1,2,7 color:blue;

[Paragraph]
It is possible to style the type of curve used for lines between items, if the default method does not meet your needs. Available curve styles include basis, bumpX, bumpY, cardinal, catmullRom, linear, monotoneX, monotoneY, natural, step, stepAfter, and stepBefore.

[Code]
basis

[Code]
bumpX

[Code]
bumpY

[Code]
cardinal

[Code]
catmullRom

[Code]
linear

[Code]
monotoneX

[Code]
monotoneY

[Code]
natural

[Code]
step

[Code]
stepAfter

[Code]
stepBefore

[Paragraph]
In this example, a left-to-right graph uses the stepBefore curve style:

[Code]
stepBefore

[Code]
%%{ init: { 'flowchart': { 'curve': 'stepBefore' } } }%%
graph LR

[Paragraph]
For a full list of available curves, including an explanation of custom curves, refer to the Shapes documentation in the d3-shape project.

[Paragraph]
It is possible to apply specific styles such as a thicker border or a different background color to a node.

[Code]
flowchart LR
    id1(Start)-->id2(Stop)
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5

[Paragraph]
More convenient than defining the style every time is to define a class of styles and attach this class to the nodes that should have a different look.

[Paragraph]
A class definition looks like the example below:

[Code]
classDef className fill:#f9f,stroke:#333,stroke-width:4px;

[Paragraph]
Also, it is possible to define style to multiple classes in one statement:

[Code]
classDef firstClassName,secondClassName font-size:12pt;

[Paragraph]
Attachment of a class to a node is done as per below:

[Code]
class nodeId1 className;

[Paragraph]
It is also possible to attach a class to a list of nodes in one statement:

[Code]
class nodeId1,nodeId2 className;

[Paragraph]
A shorter form of adding a class is to attach the classname to the node using the :::operator as per below:

[Code]
:::

[Code]
flowchart LR
    A:::someclass --> B
    classDef someclass fill:#f96

[Paragraph]
This form can be used when declaring multiple links between nodes:

[Code]
flowchart LR
    A:::foo & B:::bar --> C:::foobar
    classDef foo stroke:#f00
    classDef bar stroke:#0f0
    classDef foobar stroke:#00f

[Paragraph]
It is also possible to predefine classes in CSS styles that can be applied from the graph definition as in the example below:

[Paragraph]
Example style

[Code]
<style>
  .cssClass > rect {
    fill: #ff0000;
    stroke: #ffff00;
    stroke-width: 4px;
  }
</style>

[Paragraph]
Example definition

[Code]
flowchart LR
    A-->B[AAA<span>BBB</span>]
    B-->D
    class A cssClass

[Paragraph]
If a class is named default it will be assigned to all classes without specific class definitions.

[Code]
classDef default fill:#f9f,stroke:#333,stroke-width:4px;

[Paragraph]
It is possible to add icons from fontawesome.

[Paragraph]
The icons are accessed via the syntax fa:#icon class name#.

[Code]
flowchart TD
    B["fa:fa-twitter for peace"]
    B-->C[fa:fa-ban forbidden]
    B-->D(fa:fa-spinner)
    B-->E(A fa:fa-camera-retro perhaps?)

[Paragraph]
There are two ways to display these FontAwesome icons:

[Paragraph]
You can register your own FontAwesome icon pack following the "Registering icon packs" instructions.

[Paragraph]
Supported prefixes: fa, fab, fas, far, fal, fad.

[Code]
fa

[Code]
fab

[Code]
fas

[Code]
far

[Code]
fal

[Code]
fad

[Paragraph]
INFO

[Paragraph]
Note that it will fall back to FontAwesome CSS if FontAwesome packs are not registered.

[Paragraph]
Mermaid supports Font Awesome if the CSS is included on the website. Mermaid does not have any restriction on the version of Font Awesome that can be used.

[Paragraph]
Please refer the Official Font Awesome Documentation on how to include it in your website.

[Paragraph]
Adding this snippet in the <head> would add support for Font Awesome v6.5.1

[Code]
<head>

[Code]
<link
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
  rel="stylesheet"
/>

[Paragraph]
It is possible to use custom icons served from Font Awesome as long as the website imports the corresponding kit.

[Paragraph]
Note that this is currently a paid feature from Font Awesome.

[Paragraph]
For custom icons, you need to use the fak prefix.

[Code]
fak

[Paragraph]
Example

[Code]
flowchart TD
    B[fa:fa-twitter] %% standard icon
    B-->E(fak:fa-custom-icon-name) %% custom icon

[Paragraph]
And trying to render it

[Code]
flowchart TD
    B["fa:fa-twitter for peace"]
    B-->C["fab:fa-truck-bold a custom icon"]

[Paragraph]
In graph declarations, the statements also can now end without a semicolon. After release 0.2.16, ending a graph statement with semicolon is just optional. So the below graph declaration is also valid along with the old declarations of the graph.

[Paragraph]
A single space is allowed between vertices and the link. However there should not be any space between a vertex and its text and a link and its text. The old syntax of graph declaration will also work and hence this new feature is optional and is introduced to improve readability.

[Paragraph]
Below is the new declaration of the graph edges which is also valid along with the old declaration of the graph edges.

[Code]
flowchart LR
    A[Hard edge] -->|Link text| B(Round edge)
    B --> C{Decision}
    C -->|One| D[Result one]
    C -->|Two| E[Result two]

[Paragraph]
The layout of the diagram is done with the renderer. The default renderer is dagre.

[Paragraph]
Starting with Mermaid version 9.4, you can use an alternate renderer named elk. The elk renderer is better for larger and/or more complex diagrams.

[Paragraph]
The elk renderer is an experimental feature. You can change the renderer to elk by adding this directive:

[Code]
config:
  flowchart:
    defaultRenderer: "elk"

[Paragraph]
INFO

[Paragraph]
Note that the site needs to use mermaid version 9.4+ for this to work and have this featured enabled in the lazy-loading configuration.

[Paragraph]
It is possible to adjust the width of the rendered flowchart.

[Paragraph]
This is done by defining mermaid.flowchartConfig or by the CLI to use a JSON file with the configuration. How to use the CLI is described in the mermaidCLI page. mermaid.flowchartConfig can be set to a JSON string with config parameters or the corresponding object.

[Code]
mermaid.flowchartConfig = {
    width: 100%
}



---  Page (https://mermaid.js.org/syntax/sequenceDiagram.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A Sequence diagram is an interaction diagram that shows how processes operate with one another and in what order.

[Paragraph]
Mermaid can render sequence diagrams.

[Code]
sequenceDiagram
    Alice->>John: Hello John, how are you?
    John-->>Alice: Great!
    Alice-)John: See you later!

[Paragraph]
INFO

[Paragraph]
A note on nodes, the word "end" could potentially break the diagram, due to the way that the mermaid language is scripted.

[Paragraph]
If unavoidable, one must use parentheses(), quotation marks "", or brackets {},[], to enclose the word "end". i.e : (end), [end], {end}.

[Paragraph]
The participants can be defined implicitly as in the first example on this page. The participants or actors are rendered in order of appearance in the diagram source text. Sometimes you might want to show the participants in a different order than how they appear in the first message. It is possible to specify the actor's order of appearance by doing the following:

[Code]
sequenceDiagram
    participant Alice
    participant Bob
    Bob->>Alice: Hi Alice
    Alice->>Bob: Hi Bob

[Paragraph]
If you specifically want to use the actor symbol instead of a rectangle with text you can do so by using actor statements as per below.

[Code]
sequenceDiagram
    actor Alice
    actor Bob
    Alice->>Bob: Hi Bob
    Bob->>Alice: Hi Alice

[Paragraph]
The actor can have a convenient identifier and a descriptive label.

[Code]
sequenceDiagram
    participant A as Alice
    participant J as John
    A->>J: Hello John, how are you?
    J->>A: Great!

[Paragraph]
It is possible to create and destroy actors by messages. To do so, add a create or destroy directive before the message.

[Code]
create participant B
A --> B: Hello

[Paragraph]
Create directives support actor/participant distinction and aliases. The sender or the recipient of a message can be destroyed but only the recipient can be created.

[Code]
sequenceDiagram
    Alice->>Bob: Hello Bob, how are you ?
    Bob->>Alice: Fine, thank you. And you?
    create participant Carl
    Alice->>Carl: Hi Carl!
    create actor D as Donald
    Carl->>D: Hi!
    destroy Carl
    Alice-xCarl: We are too many
    destroy Bob
    Bob->>Alice: I agree

[Paragraph]
If an error of the following type occurs when creating or deleting an actor/participant:

[Paragraph]
The destroyed participant participant-name does not have an associated destroying message after its declaration. Please check the sequence diagram.

[Paragraph]
And fixing diagram code does not get rid of this error and rendering of all other diagrams results in the same error, then you need to update the mermaid version to (v10.7.0+).

[Paragraph]
The actor(s) can be grouped in vertical boxes. You can define a color (if not, it will be transparent) and/or a descriptive label using the following notation:

[Code]
box Aqua Group Description
... actors ...
end
box Group without description
... actors ...
end
box rgb(33,66,99)
... actors ...
end
box rgba(33,66,99,0.5)
... actors ...
end

[Paragraph]
INFO

[Paragraph]
If your group name is a color you can force the color to be transparent:

[Code]
box transparent Aqua
... actors ...
end

[Code]
sequenceDiagram
    box Purple Alice & John
    participant A
    participant J
    end
    box Another Group
    participant B
    participant C
    end
    A->>J: Hello John, how are you?
    J->>A: Great!
    A->>B: Hello Bob, how is Charley?
    B->>C: Hello Charley, how are you?

[Paragraph]
Messages can be of two displayed either solid or with a dotted line.

[Code]
[Actor][Arrow][Actor]:Message text

[Paragraph]
There are ten types of arrows currently supported:

[Code]
->

[Code]
-->

[Code]
->>

[Code]
-->>

[Code]
<<->>

[Code]
<<-->>

[Code]
-x

[Code]
--x

[Code]
-)

[Code]
--)

[Paragraph]
It is possible to activate and deactivate an actor. (de)activation can be dedicated declarations:

[Code]
sequenceDiagram
    Alice->>John: Hello John, how are you?
    activate John
    John-->>Alice: Great!
    deactivate John

[Paragraph]
There is also a shortcut notation by appending +/- suffix to the message arrow:

[Code]
+

[Code]
-

[Code]
sequenceDiagram
    Alice->>+John: Hello John, how are you?
    John-->>-Alice: Great!

[Paragraph]
Activations can be stacked for same actor:

[Code]
sequenceDiagram
    Alice->>+John: Hello John, how are you?
    Alice->>+John: John, can you hear me?
    John-->>-Alice: Hi Alice, I can hear you!
    John-->>-Alice: I feel great!

[Paragraph]
It is possible to add notes to a sequence diagram. This is done by the notation Note [ right of | left of | over ] [Actor]: Text in note content

[Paragraph]
See the example below:

[Code]
sequenceDiagram
    participant John
    Note right of John: Text in note

[Paragraph]
It is also possible to create notes spanning two participants:

[Code]
sequenceDiagram
    Alice->John: Hello John, how are you?
    Note over Alice,John: A typical interaction

[Paragraph]
Line break can be added to Note and Message:

[Code]
sequenceDiagram
    Alice->John: Hello John,<br/>how are you?
    Note over Alice,John: A typical interaction<br/>But now in two lines

[Paragraph]
Line breaks in Actor names requires aliases:

[Code]
sequenceDiagram
    participant Alice as Alice<br/>Johnson
    Alice->John: Hello John,<br/>how are you?
    Note over Alice,John: A typical interaction<br/>But now in two lines

[Paragraph]
It is possible to express loops in a sequence diagram. This is done by the notation

[Code]
loop Loop text
... statements ...
end

[Paragraph]
See the example below:

[Code]
sequenceDiagram
    Alice->John: Hello John, how are you?
    loop Every minute
        John-->Alice: Great!
    end

[Paragraph]
It is possible to express alternative paths in a sequence diagram. This is done by the notation

[Code]
alt Describing text
... statements ...
else
... statements ...
end

[Paragraph]
or if there is sequence that is optional (if without else).

[Code]
opt Describing text
... statements ...
end

[Paragraph]
See the example below:

[Code]
sequenceDiagram
    Alice->>Bob: Hello Bob, how are you?
    alt is sick
        Bob->>Alice: Not so good :(
    else is well
        Bob->>Alice: Feeling fresh like a daisy
    end
    opt Extra response
        Bob->>Alice: Thanks for asking
    end

[Paragraph]
It is possible to show actions that are happening in parallel.

[Paragraph]
This is done by the notation

[Code]
par [Action 1]
... statements ...
and [Action 2]
... statements ...
and [Action N]
... statements ...
end

[Paragraph]
See the example below:

[Code]
sequenceDiagram
    par Alice to Bob
        Alice->>Bob: Hello guys!
    and Alice to John
        Alice->>John: Hello guys!
    end
    Bob-->>Alice: Hi Alice!
    John-->>Alice: Hi Alice!

[Paragraph]
It is also possible to nest parallel blocks.

[Code]
sequenceDiagram
    par Alice to Bob
        Alice->>Bob: Go help John
    and Alice to John
        Alice->>John: I want this done today
        par John to Charlie
            John->>Charlie: Can we do this today?
        and John to Diana
            John->>Diana: Can you help us today?
        end
    end

[Paragraph]
It is possible to show actions that must happen automatically with conditional handling of circumstances.

[Paragraph]
This is done by the notation

[Code]
critical [Action that must be performed]
... statements ...
option [Circumstance A]
... statements ...
option [Circumstance B]
... statements ...
end

[Paragraph]
See the example below:

[Code]
sequenceDiagram
    critical Establish a connection to the DB
        Service-->DB: connect
    option Network timeout
        Service-->Service: Log error
    option Credentials rejected
        Service-->Service: Log different error
    end

[Paragraph]
It is also possible to have no options at all

[Code]
sequenceDiagram
    critical Establish a connection to the DB
        Service-->DB: connect
    end

[Paragraph]
This critical block can also be nested, equivalently to the par statement as seen above.

[Code]
par

[Paragraph]
It is possible to indicate a stop of the sequence within the flow (usually used to model exceptions).

[Paragraph]
This is done by the notation

[Code]
break [something happened]
... statements ...
end

[Paragraph]
See the example below:

[Code]
sequenceDiagram
    Consumer-->API: Book something
    API-->BookingService: Start booking process
    break when the booking process fails
        API-->Consumer: show failure
    end
    API-->BillingService: Start billing process

[Paragraph]
It is possible to highlight flows by providing colored background rects. This is done by the notation

[Code]
rect COLOR
... content ...
end

[Paragraph]
The colors are defined using rgb and rgba syntax.

[Code]
rect rgb(0, 255, 0)
... content ...
end

[Code]
rect rgba(0, 0, 255, .1)
... content ...
end

[Paragraph]
See the examples below:

[Code]
sequenceDiagram
    participant Alice
    participant John

    rect rgb(191, 223, 255)
    note right of Alice: Alice calls John.
    Alice->>+John: Hello John, how are you?
    rect rgb(200, 150, 255)
    Alice->>+John: John, can you hear me?
    John-->>-Alice: Hi Alice, I can hear you!
    end
    John-->>-Alice: I feel great!
    end
    Alice ->>+ John: Did you want to go to the game tonight?
    John -->>- Alice: Yeah! See you there.

[Paragraph]
Comments can be entered within a sequence diagram, which will be ignored by the parser. Comments need to be on their own line, and must be prefaced with %% (double percent signs). Any text after the start of the comment to the next newline will be treated as a comment, including any diagram syntax

[Code]
%%

[Code]
sequenceDiagram
    Alice->>John: Hello John, how are you?
    %% this is a comment
    John-->>Alice: Great!

[Paragraph]
It is possible to escape characters using the syntax exemplified here.

[Code]
sequenceDiagram
    A->>B: I #9829; you!
    B->>A: I #9829; you #infin; times more!

[Paragraph]
Numbers given are base 10, so # can be encoded as #35;. It is also supported to use HTML character names.

[Code]
#

[Code]
#35;

[Paragraph]
Because semicolons can be used instead of line breaks to define the markup, you need to use #59; to include a semicolon in message text.

[Code]
#59;

[Paragraph]
It is possible to get a sequence number attached to each arrow in a sequence diagram. This can be configured when adding mermaid to the website as shown below:

[Code]
<script>
  mermaid.initialize({ sequence: { showSequenceNumbers: true } });
</script>

[Paragraph]
It can also be turned on via the diagram code as in the diagram:

[Code]
sequenceDiagram
    autonumber
    Alice->>John: Hello John, how are you?
    loop HealthCheck
        John->>John: Fight against hypochondria
    end
    Note right of John: Rational thoughts!
    John-->>Alice: Great!
    John->>Bob: How about you?
    Bob-->>John: Jolly good!

[Paragraph]
Actors can have popup-menus containing individualized links to external pages. For example, if an actor represented a web service, useful links might include a link to the service health dashboard, repo containing the code for the service, or a wiki page describing the service.

[Paragraph]
This can be configured by adding one or more link lines with the format:

[Code]
link <actor>: <link-label> @ <link-url>

[Code]
sequenceDiagram
    participant Alice
    participant John
    link Alice: Dashboard @ https://dashboard.contoso.com/alice
    link Alice: Wiki @ https://wiki.contoso.com/alice
    link John: Dashboard @ https://dashboard.contoso.com/john
    link John: Wiki @ https://wiki.contoso.com/john
    Alice->>John: Hello John, how are you?
    John-->>Alice: Great!
    Alice-)John: See you later!

[Paragraph]
There is an advanced syntax that relies on JSON formatting. If you are comfortable with JSON format, then this exists as well.

[Paragraph]
This can be configured by adding the links lines with the format:

[Code]
links <actor>: <json-formatted link-name link-url pairs>

[Paragraph]
An example is below:

[Code]
sequenceDiagram
    participant Alice
    participant John
    links Alice: {"Dashboard": "https://dashboard.contoso.com/alice", "Wiki": "https://wiki.contoso.com/alice"}
    links John: {"Dashboard": "https://dashboard.contoso.com/john", "Wiki": "https://wiki.contoso.com/john"}
    Alice->>John: Hello John, how are you?
    John-->>Alice: Great!
    Alice-)John: See you later!

[Paragraph]
Styling of a sequence diagram is done by defining a number of css classes. During rendering these classes are extracted from the file located at src/themes/sequence.scss

[Code]
body {
  background: white;
}

.actor {
  stroke: #ccccff;
  fill: #ececff;
}
text.actor {
  fill: black;
  stroke: none;
  font-family: Helvetica;
}

.actor-line {
  stroke: grey;
}

.messageLine0 {
  stroke-width: 1.5;
  stroke-dasharray: '2 2';
  marker-end: 'url(#arrowhead)';
  stroke: black;
}

.messageLine1 {
  stroke-width: 1.5;
  stroke-dasharray: '2 2';
  stroke: black;
}

#arrowhead {
  fill: black;
}

.messageText {
  fill: black;
  stroke: none;
  font-family: 'trebuchet ms', verdana, arial;
  font-size: 14px;
}

.labelBox {
  stroke: #ccccff;
  fill: #ececff;
}

.labelText {
  fill: black;
  stroke: none;
  font-family: 'trebuchet ms', verdana, arial;
}

.loopText {
  fill: black;
  stroke: none;
  font-family: 'trebuchet ms', verdana, arial;
}

.loopLine {
  stroke-width: 2;
  stroke-dasharray: '2 2';
  marker-end: 'url(#arrowhead)';
  stroke: #ccccff;
}

.note {
  stroke: #decc93;
  fill: #fff5ad;
}

.noteText {
  fill: black;
  stroke: none;
  font-family: 'trebuchet ms', verdana, arial;
  font-size: 14px;
}

[Paragraph]
It is possible to adjust the margins for rendering the sequence diagram.

[Paragraph]
This is done by defining mermaid.sequenceConfig or by the CLI to use a json file with the configuration. How to use the CLI is described in the mermaidCLI page. mermaid.sequenceConfig can be set to a JSON string with config parameters or the corresponding object.

[Code]
mermaid.sequenceConfig

[Code]
mermaid.sequenceConfig

[Code]
mermaid.sequenceConfig = {
  diagramMarginX: 50,
  diagramMarginY: 10,
  boxTextMargin: 5,
  noteMargin: 10,
  messageMargin: 35,
  mirrorActors: true,
};



---  Page (https://mermaid.js.org/syntax/classDiagram.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
"In software engineering, a class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system by showing the system's classes, their attributes, operations (or methods), and the relationships among objects."

[Paragraph]
-Wikipedia

[Paragraph]
The class diagram is the main building block of object-oriented modeling. It is used for general conceptual modeling of the structure of the application, and for detailed modeling to translate the models into programming code. Class diagrams can also be used for data modeling. The classes in a class diagram represent both the main elements, interactions in the application, and the classes to be programmed.

[Paragraph]
Mermaid can render class diagrams.

[Code]
---
title: Animal example
---
classDiagram
    note "From Duck till Zebra"
    Animal <|-- Duck
    note for Duck "can fly\ncan swim\ncan dive\ncan help in debugging"
    Animal <|-- Fish
    Animal <|-- Zebra
    Animal : +int age
    Animal : +String gender
    Animal: +isMammal()
    Animal: +mate()
    class Duck{
        +String beakColor
        +swim()
        +quack()
    }
    class Fish{
        -int sizeInFeet
        -canEat()
    }
    class Zebra{
        +bool is_wild
        +run()
    }

[Paragraph]
Animal

[Paragraph]
+int age

[Paragraph]
+String gender

[Paragraph]
+isMammal()

[Paragraph]
+mate()

[Paragraph]
Duck

[Paragraph]
+String beakColor

[Paragraph]
+swim()

[Paragraph]
+quack()

[Paragraph]
Fish

[Paragraph]
-int sizeInFeet

[Paragraph]
-canEat()

[Paragraph]
Zebra

[Paragraph]
+bool is_wild

[Paragraph]
+run()

[Paragraph]
From Duck till Zebra

[Paragraph]
can fly\ncan swim\ncan dive\ncan help in debugging

[Paragraph]
UML provides mechanisms to represent class members, such as attributes and methods, and additional information about them. A single instance of a class in the diagram contains three compartments:

[Code]
---
title: Bank example
---
classDiagram
    class BankAccount
    BankAccount : +String owner
    BankAccount : +Bigdecimal balance
    BankAccount : +deposit(amount)
    BankAccount : +withdrawal(amount)

[Paragraph]
BankAccount

[Paragraph]
+String owner

[Paragraph]
+Bigdecimal balance

[Paragraph]
+deposit(amount)

[Paragraph]
+withdrawal(amount)

[Paragraph]
There are two ways to define a class:

[Code]
class Animal

[Code]
Vehicle <|-- Car

[Code]
classDiagram
    class Animal
    Vehicle <|-- Car

[Paragraph]
Animal

[Paragraph]
Vehicle

[Paragraph]
Car

[Paragraph]
Naming convention: a class name should be composed only of alphanumeric characters (including unicode), underscores, and dashes (-).

[Paragraph]
In case you need to provide a label for a class, you can use the following syntax:

[Code]
classDiagram
    class Animal["Animal with a label"]
    class Car["Car with *! symbols"]
    Animal --> Car

[Paragraph]
Animal with a label

[Paragraph]
Car with *! symbols

[Paragraph]
You can also use backticks to escape special characters in the label:

[Code]
classDiagram
    class `Animal Class!`
    class `Car Class`
    `Animal Class!` --> `Car Class`

[Paragraph]
Animal Class!

[Paragraph]
Car Class

[Paragraph]
UML provides mechanisms to represent class members such as attributes and methods, as well as additional information about them.

[Paragraph]
Mermaid distinguishes between attributes and functions/methods based on if the parenthesis () are present or not. The ones with () are treated as functions/methods, and all others as attributes.

[Code]
()

[Code]
()

[Paragraph]
There are two ways to define the members of a class, and regardless of whichever syntax is used to define the members, the output will still be same. The two different ways are :

[Code]
classDiagram
class BankAccount
BankAccount : +String owner
BankAccount : +BigDecimal balance
BankAccount : +deposit(amount)
BankAccount : +withdrawal(amount)

[Paragraph]
BankAccount

[Paragraph]
+String owner

[Paragraph]
+BigDecimal balance

[Paragraph]
+deposit(amount)

[Paragraph]
+withdrawal(amount)

[Code]
classDiagram
class BankAccount{
    +String owner
    +BigDecimal balance
    +deposit(amount)
    +withdrawal(amount)
}

[Paragraph]
BankAccount

[Paragraph]
+String owner

[Paragraph]
+BigDecimal balance

[Paragraph]
+deposit(amount)

[Paragraph]
+withdrawal(amount)

[Paragraph]
Optionally you can end a method/function definition with the data type that will be returned (note: there must be a space between the final ) and the return type). An example:

[Code]
)

[Code]
classDiagram
class BankAccount{
    +String owner
    +BigDecimal balance
    +deposit(amount) bool
    +withdrawal(amount) int
}

[Paragraph]
Generics can be represented as part of a class definition, and for class members/return types. In order to denote an item as generic, you enclose that type within ~ (tilde). Nested type declarations such as List<List<int>> are supported, though generics that include a comma are currently not supported. (such as List<List<K, V>>)

[Code]
~

[Code]
List<List<int>>

[Code]
List<List<K, V>>

[Paragraph]
note when a generic is used within a class definition, the generic type is NOT considered part of the class name. i.e.: for any syntax which required you to reference the class name, you need to drop the type part of the definition. This also means that mermaid does not currently support having two classes with the same name, but different generic types.

[Code]
classDiagram
class Square~Shape~{
    int id
    List~int~ position
    setPoints(List~int~ points)
    getPoints() List~int~
}

Square : -List~string~ messages
Square : +setMessages(List~string~ messages)
Square : +getMessages() List~string~
Square : +getDistanceMatrix() List~List~int~~

[Paragraph]
To describe the visibility (or encapsulation) of an attribute or method/function that is a part of a class (i.e. a class member), optional notation may be placed before that members' name:

[Code]
+

[Code]
-

[Code]
#

[Code]
~

[Paragraph]
note you can also include additional classifiers to a method definition by adding the following notation to the end of the method, i.e.: after the () or after the return type:

[Code]
()

[Code]
*

[Code]
someAbstractMethod()*

[Code]
someAbstractMethod() int*

[Code]
$

[Code]
someStaticMethod()$

[Code]
someStaticMethod() String$

[Paragraph]
note you can also include additional classifiers to a field definition by adding the following notation to the very end:

[Code]
$

[Code]
String someField$

[Paragraph]
A relationship is a general term covering the specific types of logical connections found on class and object diagrams.

[Code]
[classA][Arrow][ClassB]

[Paragraph]
There are eight different types of relations defined for classes under UML which are currently supported:

[Code]
<|--

[Code]
*--

[Code]
o--

[Code]
-->

[Code]
--

[Code]
..>

[Code]
..|>

[Code]
..

[Code]
classDiagram
classA <|-- classB
classC *-- classD
classE o-- classF
classG <-- classH
classI -- classJ
classK <.. classL
classM <|.. classN
classO .. classP

[Paragraph]
We can use the labels to describe the nature of the relation between two classes. Also, arrowheads can be used in the opposite direction as well:

[Code]
classDiagram
classA --|> classB : Inheritance
classC --* classD : Composition
classE --o classF : Aggregation
classG --> classH : Association
classI -- classJ : Link(Solid)
classK ..> classL : Dependency
classM ..|> classN : Realization
classO .. classP : Link(Dashed)

[Paragraph]
It is possible to add label text to a relation:

[Code]
[classA][Arrow][ClassB]:LabelText

[Code]
classDiagram
classA <|-- classB : implements
classC *-- classD : composition
classE o-- classF : aggregation

[Paragraph]
Relations can logically represent an N:M association:

[Code]
classDiagram
    Animal <|--|> Zebra

[Paragraph]
Here is the syntax:

[Code]
[Relation Type][Link][Relation Type]

[Paragraph]
Where Relation Type can be one of:

[Code]
Relation Type

[Code]
<|

[Code]
\*

[Code]
o

[Code]
>

[Code]
<

[Code]
|>

[Paragraph]
And Link can be one of:

[Code]
Link

[Paragraph]
Classes can also be given a special relation type that defines a lollipop interface on the class. A lollipop interface is defined using the following syntax:

[Code]
bar ()-- foo

[Code]
foo --() bar

[Paragraph]
The interface (bar) with the lollipop connects to the class (foo).

[Paragraph]
Note: Each interface that is defined is unique and is meant to not be shared between classes / have multiple edges connecting to it.

[Code]
classDiagram
  bar ()-- foo

[Code]
classDiagram
  class Class01 {
    int amount
    draw()
  }
  Class01 --() bar
  Class02 --() bar

  foo ()-- Class01

[Paragraph]
A namespace groups classes.

[Code]
classDiagram
namespace BaseShapes {
    class Triangle
    class Rectangle {
      double width
      double height
    }
}

[Paragraph]
Multiplicity or cardinality in class diagrams indicates the number of instances of one class that can be linked to an instance of the other class. For example, each company will have one or more employees (not zero), and each employee currently works for zero or one companies.

[Paragraph]
Multiplicity notations are placed near the end of an association.

[Paragraph]
The different cardinality options are :

[Code]
1

[Code]
0..1

[Code]
1..*

[Code]
*

[Code]
n

[Code]
0..n

[Code]
1..n

[Paragraph]
Cardinality can be easily defined by placing the text option within quotes " before or after a given arrow. For example:

[Code]
"

[Code]
[classA] "cardinality1" [Arrow] "cardinality2" [ClassB]:LabelText

[Code]
classDiagram
    Customer "1" --> "*" Ticket
    Student "1" --> "1..*" Course
    Galaxy --> "many" Star : Contains

[Paragraph]
It is possible to annotate classes with markers to provide additional metadata about the class. This can give a clearer indication about its nature. Some common annotations include:

[Code]
<<Interface>>

[Code]
<<Abstract>>

[Code]
<<Service>>

[Code]
<<Enumeration>>

[Paragraph]
Annotations are defined within the opening << and closing >>. There are two ways to add an annotation to a class, and either way the output will be same:

[Code]
<<

[Code]
>>

[Paragraph]
Tip:
In Mermaid class diagrams, annotations like <<interface>> can be attached in two ways:

[Code]
<<interface>>

[Paragraph]
Inline with the class definition (Recommended for consistency):

[Code]
classDiagram
  class Shape <<interface>>

[Paragraph]
Separate line after the class definition:

[Code]
classDiagram
  class Shape
  <<interface>> Shape

[Paragraph]
Both methods are fully supported and produce identical diagrams.
However, it is recommended to use the inline style for better readability and consistent formatting across diagrams.

[Code]
classDiagram
class Shape
<<interface>> Shape
Shape : noOfVertices
Shape : draw()

[Code]
classDiagram
class Shape{
    <<interface>>
    noOfVertices
    draw()
}
class Color{
    <<enumeration>>
    RED
    BLUE
    GREEN
    WHITE
    BLACK
}

[Paragraph]
Comments can be entered within a class diagram, which will be ignored by the parser. Comments need to be on their own line, and must be prefaced with %% (double percent signs). Any text until the next newline will be treated as a comment, including any class diagram syntax.

[Code]
%%

[Code]
classDiagram
%% This whole line is a comment classDiagram class Shape <<interface>>
class Shape{
    <<interface>>
    noOfVertices
    draw()
}

[Paragraph]
With class diagrams you can use the direction statement to set the direction in which the diagram will render:

[Code]
classDiagram
  direction RL
  class Student {
    -idCard : IdCard
  }
  class IdCard{
    -id : int
    -name : string
  }
  class Bike{
    -id : int
    -name : string
  }
  Student "1" --o "1" IdCard : carries
  Student "1" --o "1" Bike : rides

[Paragraph]
It is possible to bind a click event to a node. The click can lead to either a javascript callback or to a link which will be opened in a new browser tab. Note: This functionality is disabled when using securityLevel='strict' and enabled when using securityLevel='loose'.

[Code]
securityLevel='strict'

[Code]
securityLevel='loose'

[Paragraph]
You would define these actions on a separate line after all classes have been declared.

[Code]
action className "reference" "tooltip"
click className call callback() "tooltip"
click className href "url" "tooltip"

[Code]
link

[Code]
callback

[Paragraph]
It is possible to add notes on the diagram using note "line1\nline2". A note can be added for a specific class using note for <CLASS NAME> "line1\nline2".

[Code]
note "line1\nline2"

[Code]
note for <CLASS NAME> "line1\nline2"

[Code]
classDiagram
    note "This is a general note"
    note for MyClass "This is a note for a class"
    class MyClass{
    }

[Paragraph]
URL Link:

[Code]
classDiagram
class Shape
link Shape "https://www.github.com" "This is a tooltip for a link"
class Shape2
click Shape2 href "https://www.github.com" "This is a tooltip for a link"

[Paragraph]
Callback:

[Code]
classDiagram
class Shape
callback Shape "callbackFunction" "This is a tooltip for a callback"
class Shape2
click Shape2 call callbackFunction() "This is a tooltip for a callback"

[Code]
<script>
  const callbackFunction = function () {
    alert('A callback was triggered');
  };
</script>

[Code]
classDiagram
    class Class01
    class Class02
    callback Class01 "callbackFunction" "Callback tooltip"
    link Class02 "https://www.github.com" "This is a link"
    class Class03
    class Class04
    click Class03 call callbackFunction() "Callback tooltip"
    click Class04 href "https://www.github.com" "This is a link"

[Paragraph]
Success The tooltip functionality and the ability to link to urls are available from version 0.5.2.

[Paragraph]
Beginner's tip—a full example using interactive links in an HTML page:

[Code]
<body>
  <pre class="mermaid">
    classDiagram
    Animal <|-- Duck
    Animal <|-- Fish
    Animal <|-- Zebra
    Animal : +int age
    Animal : +String gender
    Animal: +isMammal()
    Animal: +mate()
    class Duck{
      +String beakColor
      +swim()
      +quack()
      }
    class Fish{
      -int sizeInFeet
      -canEat()
      }
    class Zebra{
      +bool is_wild
      +run()
      }

      callback Duck "callback" "Tooltip"
      link Zebra "https://www.github.com" "This is a link"
  </pre>

  <script>
    const callback = function () {
      alert('A callback was triggered');
    };
    const config = {
      startOnLoad: true,
      securityLevel: 'loose',
    };
    mermaid.initialize(config);
  </script>
</body>

[Paragraph]
It is possible to apply specific styles such as a thicker border or a different background color to an individual node using the style keyword.

[Code]
style

[Paragraph]
Note that notes and namespaces cannot be styled individually but do support themes.

[Code]
classDiagram
  class Animal
  class Mineral
  style Animal fill:#f9f,stroke:#333,stroke-width:4px
  style Mineral fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5

[Paragraph]
More convenient than defining the style every time is to define a class of styles and attach this class to the nodes that should have a different look.

[Paragraph]
A class definition looks like the example below:

[Code]
classDef className fill:#f9f,stroke:#333,stroke-width:4px;

[Paragraph]
Also, it is possible to define style to multiple classes in one statement:

[Code]
classDef firstClassName,secondClassName font-size:12pt;

[Paragraph]
Attachment of a class to a node is done as per below:

[Code]
cssClass "nodeId1" className;

[Paragraph]
It is also possible to attach a class to a list of nodes in one statement:

[Code]
cssClass "nodeId1,nodeId2" className;

[Paragraph]
A shorter form of adding a class is to attach the classname to the node using the ::: operator:

[Code]
:::

[Code]
classDiagram
    class Animal:::someclass
    classDef someclass fill:#f96

[Paragraph]
Or:

[Code]
classDiagram
    class Animal:::someclass {
        -int sizeInFeet
        -canEat()
    }
    classDef someclass fill:#f96

[Paragraph]
If a class is named default it will be applied to all nodes. Specific styles and classes should be defined afterwards to override the applied default styling.

[Code]
classDef default fill:#f9f,stroke:#333,stroke-width:4px;

[Code]
classDiagram
  class Animal:::pink
  class Mineral

  classDef default fill:#f96,color:red
  classDef pink color:#f9f

[Paragraph]
It is also possible to predefine classes in CSS styles that can be applied from the graph definition as in the example below:

[Paragraph]
Example style

[Code]
<style>
  .styleClass > * > g {
    fill: #ff0000;
    stroke: #ffff00;
    stroke-width: 4px;
  }
</style>

[Paragraph]
Example definition

[Code]
classDiagram
    class Animal:::styleClass

[Paragraph]
cssClasses cannot be added using this shorthand method at the same time as a relation statement.

[Paragraph]
It is possible to hide the empty members box of a class node.

[Paragraph]
This is done by changing the hideEmptyMembersBox value of the class diagram configuration. For more information on how to edit the Mermaid configuration see the configuration page.

[Code]
---
  config:
    class:
      hideEmptyMembersBox: true
---
classDiagram
  class Duck



---  Page (https://mermaid.js.org/syntax/stateDiagram.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
"A state diagram is a type of diagram used in computer science and related fields to describe the behavior of systems. State diagrams require that the system described is composed of a finite number of states; sometimes, this is indeed the case, while at other times this is a reasonable abstraction." Wikipedia

[Paragraph]
Mermaid can render state diagrams. The syntax tries to be compliant with the syntax used in plantUml as this will make it easier for users to share diagrams between mermaid and plantUml.

[Code]
---
title: Simple sample
---
stateDiagram-v2
    [*] --> Still
    Still --> [*]

    Still --> Moving
    Moving --> Still
    Moving --> Crash
    Crash --> [*]

[Paragraph]
Older renderer:

[Code]
stateDiagram
    [*] --> Still
    Still --> [*]

    Still --> Moving
    Moving --> Still
    Moving --> Crash
    Crash --> [*]

[Paragraph]
In state diagrams systems are described in terms of states and how one state can change to another state via a transition. The example diagram above shows three states: Still, Moving and Crash. You start in the Still state. From Still you can change to the Moving state. From Moving you can change either back to the Still state or to the Crash state. There is no transition from Still to Crash. (You can't crash if you're still.)

[Paragraph]
A state can be declared in multiple ways. The simplest way is to define a state with just an id:

[Code]
stateDiagram-v2
    stateId

[Paragraph]
Another way is by using the state keyword with a description as per below:

[Code]
stateDiagram-v2
    state "This is a state description" as s2

[Paragraph]
Another way to define a state with a description is to define the state id followed by a colon and the description:

[Code]
stateDiagram-v2
    s2 : This is a state description

[Paragraph]
Transitions are path/edges when one state passes into another. This is represented using text arrow, "-->".

[Paragraph]
When you define a transition between two states and the states are not already defined, the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way.

[Code]
stateDiagram-v2
    s1 --> s2

[Paragraph]
It is possible to add text to a transition to describe what it represents:

[Code]
stateDiagram-v2
    s1 --> s2: A transition

[Paragraph]
There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state.

[Code]
stateDiagram-v2
    [*] --> s1
    s1 --> [*]

[Paragraph]
In a real world use of state diagrams you often end up with diagrams that are multidimensional as one state can have several internal states. These are called composite states in this terminology.

[Paragraph]
In order to define a composite state you need to use the state keyword followed by an id and the body of the composite state between {}. You can name a composite state on a separate line just like a simple state. See the example below:

[Code]
stateDiagram-v2
    [*] --> First
    state First {
        [*] --> second
        second --> [*]
    }

    [*] --> NamedComposite
    NamedComposite: Another Composite
    state NamedComposite {
        [*] --> namedSimple
        namedSimple --> [*]
        namedSimple: Another simple
    }

[Paragraph]
You can do this in several layers:

[Code]
stateDiagram-v2
    [*] --> First

    state First {
        [*] --> Second

        state Second {
            [*] --> second
            second --> Third

            state Third {
                [*] --> third
                third --> [*]
            }
        }
    }

[Paragraph]
You can also define transitions also between composite states:

[Code]
stateDiagram-v2
    [*] --> First
    First --> Second
    First --> Third

    state First {
        [*] --> fir
        fir --> [*]
    }
    state Second {
        [*] --> sec
        sec --> [*]
    }
    state Third {
        [*] --> thi
        thi --> [*]
    }

[Paragraph]
You cannot define transitions between internal states belonging to different composite states

[Paragraph]
Sometimes you need to model a choice between two or more paths, you can do so using <<choice>>.

[Code]
stateDiagram-v2
    state if_state <<choice>>
    [*] --> IsPositive
    IsPositive --> if_state
    if_state --> False: if n < 0
    if_state --> True : if n >= 0

[Paragraph]
It is possible to specify a fork in the diagram using <<fork>> <<join>>.

[Code]
stateDiagram-v2
    state fork_state <<fork>>
      [*] --> fork_state
      fork_state --> State2
      fork_state --> State3

      state join_state <<join>>
      State2 --> join_state
      State3 --> join_state
      join_state --> State4
      State4 --> [*]

[Paragraph]
Sometimes nothing says it better than a Post-it note. That is also the case in state diagrams.

[Paragraph]
Here you can choose to put the note to the right of or to the left of a node.

[Code]
stateDiagram-v2
        State1: The state with a note
        note right of State1
            Important information! You can write
            notes.
        end note
        State1 --> State2
        note left of State2 : This is the note to the left.

[Paragraph]
As in plantUml you can specify concurrency using the -- symbol.

[Code]
stateDiagram-v2
    [*] --> Active

    state Active {
        [*] --> NumLockOff
        NumLockOff --> NumLockOn : EvNumLockPressed
        NumLockOn --> NumLockOff : EvNumLockPressed
        --
        [*] --> CapsLockOff
        CapsLockOff --> CapsLockOn : EvCapsLockPressed
        CapsLockOn --> CapsLockOff : EvCapsLockPressed
        --
        [*] --> ScrollLockOff
        ScrollLockOff --> ScrollLockOn : EvScrollLockPressed
        ScrollLockOn --> ScrollLockOff : EvScrollLockPressed
    }

[Paragraph]
With state diagrams you can use the direction statement to set the direction which the diagram will render like in this example.

[Code]
stateDiagram
    direction LR
    [*] --> A
    A --> B
    B --> C
    state B {
      direction LR
      a --> b
    }
    B --> D

[Paragraph]
Comments can be entered within a state diagram chart, which will be ignored by the parser. Comments need to be on their own line, and must be prefaced with %% (double percent signs). Any text after the start of the comment to the next newline will be treated as a comment, including any diagram syntax

[Code]
%%

[Code]
stateDiagram-v2
    [*] --> Still
    Still --> [*]
%% this is a comment
    Still --> Moving
    Moving --> Still %% another comment
    Moving --> Crash
    Crash --> [*]

[Paragraph]
As with other diagrams (like flowcharts), you can define a style in the diagram itself and apply that named style to a state or states in the diagram.

[Paragraph]
These are the current limitations with state diagram classDefs:

[Paragraph]
These are in development and will be available in a future version.

[Paragraph]
You define a style using the classDef keyword, which is short for "class definition" (where "class" means something like a CSS class) followed by a name for the style, and then one or more property-value pairs. Each property-value pair is a valid CSS property name followed by a colon (:) and then a value.

[Code]
classDef

[Code]
:

[Paragraph]
Here is an example of a classDef with just one property-value pair:

[Code]
classDef movement font-style:italic;

[Paragraph]
where

[Code]
movement

[Code]
font-style

[Code]
italic

[Paragraph]
If you want to have more than one property-value pair then you put a comma (,) between each property-value pair.

[Code]
,

[Paragraph]
Here is an example with three property-value pairs:

[Code]
classDef badBadEvent fill:#f00,color:white,font-weight:bold,stroke-width:2px,stroke:yellow

[Paragraph]
where

[Code]
badBadEvent

[Code]
fill

[Code]
#f00

[Code]
color

[Code]
white

[Code]
font-weight

[Code]
bold

[Code]
stroke-width

[Code]
2px

[Code]
stroke

[Code]
yellow

[Paragraph]
There are two ways to apply a classDef style to a state:

[Code]
classDef

[Code]
class

[Code]
:::

[Code]
class

[Paragraph]
A class statement tells Mermaid to apply the named classDef to one or more classes. The form is:

[Code]
class

[Code]
class [one or more state names, separated by commas] [name of a style defined with classDef]

[Paragraph]
Here is an example applying the badBadEvent style to a state named Crash:

[Code]
badBadEvent

[Code]
Crash

[Code]
class Crash badBadEvent

[Paragraph]
Here is an example applying the movement style to the two states Moving and Crash:

[Code]
movement

[Code]
Moving

[Code]
Crash

[Code]
class Moving, Crash movement

[Paragraph]
Here is a diagram that shows the examples in use. Note that the Crash state has two classDef styles applied: movement and badBadEvent

[Code]
Crash

[Code]
movement

[Code]
badBadEvent

[Code]
stateDiagram
   direction TB

   accTitle: This is the accessible title
   accDescr: This is an accessible description

   classDef notMoving fill:white
   classDef movement font-style:italic
   classDef badBadEvent fill:#f00,color:white,font-weight:bold,stroke-width:2px,stroke:yellow

   [*]--> Still
   Still --> [*]
   Still --> Moving
   Moving --> Still
   Moving --> Crash
   Crash --> [*]

   class Still notMoving
   class Moving, Crash movement
   class Crash badBadEvent
   class end badBadEvent

[Code]
:::

[Paragraph]
You can apply a classDef style to a state using the ::: (three colons) operator. The syntax is

[Code]
:::

[Code]
[state]:::[style name]

[Paragraph]
You can use this in a diagram within a statement using a class. This includes the start and end states. For example:

[Code]
stateDiagram
   direction TB

   accTitle: This is the accessible title
   accDescr: This is an accessible description

   classDef notMoving fill:white
   classDef movement font-style:italic;
   classDef badBadEvent fill:#f00,color:white,font-weight:bold,stroke-width:2px,stroke:yellow

   [*] --> Still:::notMoving
   Still --> [*]
   Still --> Moving:::movement
   Moving --> Still
   Moving --> Crash:::movement
   Crash:::badBadEvent --> [*]

[Paragraph]
Spaces can be added to a state by first defining the state with an id and then referencing the id later.

[Paragraph]
In the following example there is a state with the id yswsii and description Your state with spaces in it. After it has been defined, yswsii is used in the diagram in the first transition ([*] --> yswsii) and also in the transition to YetAnotherState (yswsii --> YetAnotherState). (yswsii has been styled so that it is different from the other states.)

[Code]
[*] --> yswsii

[Code]
yswsii --> YetAnotherState

[Code]
stateDiagram
    classDef yourState font-style:italic,font-weight:bold,fill:white

    yswsii: Your state with spaces in it
    [*] --> yswsii:::yourState
    [*] --> SomeOtherState
    SomeOtherState --> YetAnotherState
    yswsii --> YetAnotherState
    YetAnotherState --> [*]



---  Page (https://mermaid.js.org/syntax/entityRelationshipDiagram.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
An entity–relationship model (or ER model) describes interrelated things of interest in a specific domain of knowledge. A basic ER model is composed of entity types (which classify the things of interest) and specifies relationships that can exist between entities (instances of those entity types) Wikipedia.

[Paragraph]
Note that practitioners of ER modelling almost always refer to entity types simply as entities. For example the CUSTOMER entity type would be referred to simply as the CUSTOMER entity. This is so common it would be inadvisable to do anything else, but technically an entity is an abstract instance of an entity type, and this is what an ER diagram shows - abstract instances, and the relationships between them. This is why entities are always named using singular nouns.

[Code]
CUSTOMER

[Code]
CUSTOMER

[Paragraph]
Mermaid can render ER diagrams

[Code]
---
title: Order example
---
erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses

[Paragraph]
Entity names are often capitalised, although there is no accepted standard on this, and it is not required in Mermaid.

[Paragraph]
Relationships between entities are represented by lines with end markers representing cardinality. Mermaid uses the most popular crow's foot notation. The crow's foot intuitively conveys the possibility of many instances of the entity that it connects to.

[Paragraph]
ER diagrams can be used for various purposes, ranging from abstract logical models devoid of any implementation details, through to physical models of relational database tables. It can be useful to include attribute definitions on ER diagrams to aid comprehension of the purpose and meaning of entities. These do not necessarily need to be exhaustive; often a small subset of attributes is enough. Mermaid allows them to be defined in terms of their type and name.

[Code]
erDiagram
    CUSTOMER ||--o{ ORDER : places
    CUSTOMER {
        string name
        string custNumber
        string sector
    }
    ORDER ||--|{ LINE-ITEM : contains
    ORDER {
        int orderNumber
        string deliveryAddress
    }
    LINE-ITEM {
        string productCode
        int quantity
        float pricePerUnit
    }

[Paragraph]
When including attributes on ER diagrams, you must decide whether to include foreign keys as attributes. This probably depends on how closely you are trying to represent relational table structures. If your diagram is a logical model which is not meant to imply a relational implementation, then it is better to leave these out because the associative relationships already convey the way that entities are associated. For example, a JSON data structure can implement a one-to-many relationship without the need for foreign key properties, using arrays. Similarly an object-oriented programming language may use pointers or references to collections. Even for models that are intended for relational implementation, you might decide that inclusion of foreign key attributes duplicates information already portrayed by the relationships, and does not add meaning to entities. Ultimately, it's your choice.

[Paragraph]
Mermaid syntax for ER diagrams is compatible with PlantUML, with an extension to label the relationship. Each statement consists of the following parts:

[Code]
<first-entity> [<relationship> <second-entity> : <relationship-label>]

[Paragraph]
Where:

[Code]
first-entity

[Code]
relationship

[Code]
second-entity

[Code]
relationship-label

[Paragraph]
For example:

[Code]
PROPERTY ||--|{ ROOM : contains

[Paragraph]
This statement can be read as a property contains one or more rooms, and a room is part of one and only one property. You can see that the label here is from the first entity's perspective: a property contains a room, but a room does not contain a property. When considered from the perspective of the second entity, the equivalent label is usually very easy to infer. (Some ER diagrams label relationships from both perspectives, but this is not supported here, and is usually superfluous).

[Paragraph]
Only the first-entity part of a statement is mandatory. This makes it possible to show an entity with no relationships, which can be useful during iterative construction of diagrams. If any other parts of a statement are specified, then all parts are mandatory.

[Code]
first-entity

[Paragraph]
Entity names, relationships, and attributes all support unicode text.

[Code]
erDiagram
    "This ❤ Unicode"

[Paragraph]
Markdown formatting and text is also supported.

[Code]
erDiagram
    "This **is** _Markdown_"

[Paragraph]
The relationship part of each statement can be broken down into three sub-components:

[Code]
relationship

[Paragraph]
Cardinality is a property that describes how many elements of another entity can be related to the entity in question. In the above example a PROPERTY can have one or more ROOM instances associated to it, whereas a ROOM can only be associated with one PROPERTY. In each cardinality marker there are two characters. The outermost character represents a maximum value, and the innermost character represents a minimum value. The table below summarises possible cardinalities.

[Code]
PROPERTY

[Code]
ROOM

[Code]
ROOM

[Code]
PROPERTY

[Code]
|o

[Code]
o|

[Code]
||

[Code]
||

[Code]
}o

[Code]
o{

[Code]
}|

[Code]
|{

[Paragraph]
Aliases

[Paragraph]
Relationships may be classified as either identifying or non-identifying and these are rendered with either solid or dashed lines respectively. This is relevant when one of the entities in question cannot have independent existence without the other. For example a firm that insures people to drive cars might need to store data on NAMED-DRIVERs. In modelling this we might start out by observing that a CAR can be driven by many PERSON instances, and a PERSON can drive many CARs - both entities can exist without the other, so this is a non-identifying relationship that we might specify in Mermaid as: PERSON }|..|{ CAR : "driver". Note the two dots in the middle of the relationship that will result in a dashed line being drawn between the two entities. But when this many-to-many relationship is resolved into two one-to-many relationships, we observe that a NAMED-DRIVER cannot exist without both a PERSON and a CAR - the relationships become identifying and would be specified using hyphens, which translate to a solid line:

[Code]
NAMED-DRIVER

[Code]
CAR

[Code]
PERSON

[Code]
PERSON

[Code]
CAR

[Code]
PERSON }|..|{ CAR : "driver"

[Code]
NAMED-DRIVER

[Code]
PERSON

[Code]
CAR

[Paragraph]
Aliases

[Code]
erDiagram
    CAR ||--o{ NAMED-DRIVER : allows
    PERSON }o..o{ NAMED-DRIVER : is

[Code]
erDiagram
    CAR 1 to zero or more NAMED-DRIVER : allows
    PERSON many(0) optionally to 0+ NAMED-DRIVER : is

[Paragraph]
Attributes can be defined for entities by specifying the entity name followed by a block containing multiple type name pairs, where a block is delimited by an opening { and a closing }. The attributes are rendered inside the entity boxes. For example:

[Code]
type name

[Code]
{

[Code]
}

[Code]
erDiagram
    CAR ||--o{ NAMED-DRIVER : allows
    CAR {
        string registrationNumber
        string make
        string model
    }
    PERSON ||--o{ NAMED-DRIVER : is
    PERSON {
        string firstName
        string lastName
        int age
    }

[Paragraph]
The type values must begin with an alphabetic character and may contain digits, hyphens, underscores, parentheses and square brackets. The name values follow a similar format to type, but may start with an asterisk as another option to indicate an attribute is a primary key. Other than that, there are no restrictions, and there is no implicit set of valid data types.

[Code]
type

[Code]
name

[Code]
type

[Paragraph]
An alias can be added to an entity using square brackets. If provided, the alias will be showed in the diagram instead of the entity name. Alias names follow all of the same rules as entity names.

[Code]
erDiagram
    p[Person] {
        string firstName
        string lastName
    }
    a["Customer Account"] {
        string email
    }
    p ||--o| a : has

[Paragraph]
Attributes may also have a key or comment defined. Keys can be PK, FK or UK, for Primary Key, Foreign Key or Unique Key (markdown formatting and unicode is not supported for keys). To specify multiple key constraints on a single attribute, separate them with a comma (e.g., PK, FK). A comment is defined by double quotes at the end of an attribute. Comments themselves cannot have double-quote characters in them.

[Code]
key

[Code]
PK

[Code]
FK

[Code]
UK

[Code]
PK, FK

[Code]
comment

[Code]
erDiagram
    CAR ||--o{ NAMED-DRIVER : allows
    CAR {
        string registrationNumber PK
        string make
        string model
        string[] parts
    }
    PERSON ||--o{ NAMED-DRIVER : is
    PERSON {
        string driversLicense PK "The license #"
        string(99) firstName "Only 99 characters are allowed"
        string lastName
        string phone UK
        int age
    }
    NAMED-DRIVER {
        string carRegistrationNumber PK, FK
        string driverLicence PK, FK
    }
    MANUFACTURER only one to zero or more CAR : makes

[Paragraph]
The direction statement declares the direction of the diagram.

[Paragraph]
This declares that the diagram is oriented from top to bottom (TB). This can be reversed to be oriented from bottom to top (BT).

[Code]
TB

[Code]
BT

[Code]
erDiagram
    direction TB
    CUSTOMER ||--o{ ORDER : places
    CUSTOMER {
        string name
        string custNumber
        string sector
    }
    ORDER ||--|{ LINE-ITEM : contains
    ORDER {
        int orderNumber
        string deliveryAddress
    }
    LINE-ITEM {
        string productCode
        int quantity
        float pricePerUnit
    }

[Paragraph]
This declares that the diagram is oriented from left to right (LR). This can be reversed to be oriented from right to left (RL).

[Code]
LR

[Code]
RL

[Code]
erDiagram
    direction LR
    CUSTOMER ||--o{ ORDER : places
    CUSTOMER {
        string name
        string custNumber
        string sector
    }
    ORDER ||--|{ LINE-ITEM : contains
    ORDER {
        int orderNumber
        string deliveryAddress
    }
    LINE-ITEM {
        string productCode
        int quantity
        float pricePerUnit
    }

[Paragraph]
Possible diagram orientations are:

[Paragraph]
It is possible to apply specific styles such as a thicker border or a different background color to a node.

[Code]
erDiagram
    id1||--||id2 : label
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5

[Paragraph]
It is also possible to attach styles to a list of nodes in one statement:

[Code]
style nodeId1,nodeId2 styleList

[Paragraph]
More convenient than defining the style every time is to define a class of styles and attach this class to the nodes that should have a different look.

[Paragraph]
A class definition looks like the example below:

[Code]
classDef className fill:#f9f,stroke:#333,stroke-width:4px

[Paragraph]
It is also possible to define multiple classes in one statement:

[Code]
classDef firstClassName,secondClassName font-size:12pt

[Paragraph]
Attachment of a class to a node is done as per below:

[Code]
class nodeId1 className

[Paragraph]
It is also possible to attach a class to a list of nodes in one statement:

[Code]
class nodeId1,nodeId2 className

[Paragraph]
Multiple classes can be attached at the same time as well:

[Code]
class nodeId1,nodeId2 className1,className2

[Paragraph]
A shorter form of adding a class is to attach the classname to the node using the :::operator as per below:

[Code]
:::

[Code]
erDiagram
    direction TB
    CAR:::someclass {
        string registrationNumber
        string make
        string model
    }
    PERSON:::someclass {
        string firstName
        string lastName
        int age
    }
    HOUSE:::someclass

    classDef someclass fill:#f96

[Paragraph]
This form can be used when declaring relationships between entities:

[Code]
erDiagram
    CAR {
        string registrationNumber
        string make
        string model
    }
    PERSON {
        string firstName
        string lastName
        int age
    }
    PERSON:::foo ||--|| CAR : owns
    PERSON o{--|| HOUSE:::bar : has

    classDef foo stroke:#f00
    classDef bar stroke:#0f0
    classDef foobar stroke:#00f

[Paragraph]
Similar to the class statement, the shorthand syntax can also apply multiple classes at once:

[Code]
nodeId:::className1,className2

[Paragraph]
If a class is named default it will be assigned to all classes without specific class definitions.

[Code]
classDef default fill:#f9f,stroke:#333,stroke-width:4px;

[Paragraph]
Note: Custom styles from style or other class statements take priority and will overwrite the default styles. (e.g. The default class gives nodes a background color of pink but the blue class will give that node a background color of blue if applied.)

[Code]
default

[Code]
blue

[Code]
erDiagram
    CAR {
        string registrationNumber
        string make
        string model
    }
    PERSON {
        string firstName
        string lastName
        int age
    }
    PERSON:::foo ||--|| CAR : owns
    PERSON o{--|| HOUSE:::bar : has

    classDef default fill:#f9f,stroke-width:4px
    classDef foo stroke:#f00
    classDef bar stroke:#0f0
    classDef foobar stroke:#00f

[Paragraph]
The layout of the diagram is handled by render(). The default layout is dagre.

[Code]
render()

[Paragraph]
For larger or more-complex diagrams, you can alternatively apply the ELK (Eclipse Layout Kernel) layout using your YAML frontmatter's config. For more information, see Customizing ELK Layout.

[Code]
config

[Code]
---
config:
  layout: elk
---

[Paragraph]
Your Mermaid code should be similar to the following:

[Code]
---
title: Order example
config:
    layout: elk
---
erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses

[Paragraph]
INFO

[Paragraph]
Note that the site needs to use mermaid version 9.4+ for this to work and have this featured enabled in the lazy-loading configuration.



---  Page (https://mermaid.js.org/syntax/userJourney.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
User journeys describe at a high level of detail exactly what steps different users take to complete a specific task within a system, application or website. This technique shows the current (as-is) user workflow, and reveals areas of improvement for the to-be workflow. (Wikipedia)

[Paragraph]
Mermaid can render user journey diagrams:

[Code]


[Paragraph]
Each user journey is split into sections, these describe the part of the task the user is trying to complete.

[Paragraph]
Tasks syntax is Task name: <score>: <comma separated list of actors>

[Code]
Task name: <score>: <comma separated list of actors>



---  Page (https://mermaid.js.org/syntax/gantt.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A Gantt chart is a type of bar chart, first developed by Karol Adamiecki in 1896, and independently by Henry Gantt in the 1910s, that illustrates a project schedule and the amount of time it would take for any one project to finish. Gantt charts illustrate number of days between the start and finish dates of the terminal elements and summary elements of a project.

[Paragraph]
Gantt Charts will record each scheduled task as one continuous bar that extends from the left to the right. The x axis represents time and the y records the different tasks and the order in which they are to be completed.

[Paragraph]
It is important to remember that when a date, day, or collection of dates specific to a task are "excluded", the Gantt Chart will accommodate those changes by extending an equal number of days, towards the right, not by creating a gap inside the task. As shown here

[Paragraph]
However, if the excluded dates are between two tasks that are set to start consecutively, the excluded dates will be skipped graphically and left blank, and the following task will begin after the end of the excluded dates. As shown here

[Paragraph]
A Gantt chart is useful for tracking the amount of time it would take before a project is finished, but it can also be used to graphically represent "non-working days", with a few tweaks.

[Paragraph]
Mermaid can render Gantt diagrams as SVG, PNG or a MarkDown link that can be pasted into docs.

[Code]
gantt
    title A Gantt Diagram
    dateFormat YYYY-MM-DD
    section Section
        A task          :a1, 2014-01-01, 30d
        Another task    :after a1, 20d
    section Another
        Task in Another :2014-01-12, 12d
        another task    :24d

[Code]
gantt
    dateFormat  YYYY-MM-DD
    title       Adding GANTT diagram functionality to mermaid
    excludes    weekends
    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week ("sunday") or "weekends", but not the word "weekdays".)

    section A section
    Completed task            :done,    des1, 2014-01-06,2014-01-08
    Active task               :active,  des2, 2014-01-09, 3d
    Future task               :         des3, after des2, 5d
    Future task2              :         des4, after des3, 5d

    section Critical tasks
    Completed task in the critical line :crit, done, 2014-01-06,24h
    Implement parser and jison          :crit, done, after des1, 2d
    Create tests for parser             :crit, active, 3d
    Future task in critical line        :crit, 5d
    Create tests for renderer           :2d
    Add to mermaid                      :until isadded
    Functionality added                 :milestone, isadded, 2014-01-25, 0d

    section Documentation
    Describe gantt syntax               :active, a1, after des1, 3d
    Add gantt diagram to demo page      :after a1  , 20h
    Add another diagram to demo page    :doc1, after a1  , 48h

    section Last section
    Describe gantt syntax               :after doc1, 3d
    Add gantt diagram to demo page      :20h
    Add another diagram to demo page    :48h

[Paragraph]
Tasks are by default sequential. A task start date defaults to the end date of the preceding task.

[Paragraph]
A colon, :, separates the task title from its metadata. Metadata items are separated by a comma, ,. Valid tags are active, done, crit, and milestone. Tags are optional, but if used, they must be specified first. After processing the tags, the remaining metadata items are interpreted as follows:

[Code]
:

[Code]
,

[Code]
active

[Code]
done

[Code]
crit

[Code]
milestone

[Code]
dateFormat

[Code]
after <otherTaskID> [[otherTaskID2 [otherTaskID3]]...]

[Code]
later <taskID>

[Code]
<taskID>, <startDate>, <endDate>

[Code]
startdate

[Code]
dateformat

[Code]
endDate

[Code]
dateformat

[Code]
taskID

[Code]
<taskID>, <startDate>, <length>

[Code]
startdate

[Code]
dateformat

[Code]
length

[Code]
taskID

[Code]
<taskID>, after <otherTaskId>, <endDate>

[Code]
otherTaskID

[Code]
endDate

[Code]
dateformat

[Code]
taskID

[Code]
<taskID>, after <otherTaskId>, <length>

[Code]
otherTaskID

[Code]
length

[Code]
taskID

[Code]
<taskID>, <startDate>, until <otherTaskId>

[Code]
startdate

[Code]
dateformat

[Code]
otherTaskID

[Code]
taskID

[Code]
<taskID>, after <otherTaskId>, until <otherTaskId>

[Code]
otherTaskID

[Code]
otherTaskID

[Code]
taskID

[Code]
<startDate>, <endDate>

[Code]
startdate

[Code]
dateformat

[Code]
enddate

[Code]
dateformat

[Code]
<startDate>, <length>

[Code]
startdate

[Code]
dateformat

[Code]
length

[Code]
after <otherTaskID>, <endDate>

[Code]
otherTaskID

[Code]
enddate

[Code]
dateformat

[Code]
after <otherTaskID>, <length>

[Code]
otherTaskID

[Code]
length

[Code]
<startDate>, until <otherTaskId>

[Code]
startdate

[Code]
dateformat

[Code]
otherTaskID

[Code]
after <otherTaskId>, until <otherTaskId>

[Code]
otherTaskID

[Code]
otherTaskID

[Code]
<endDate>

[Code]
enddate

[Code]
dateformat

[Code]
<length>

[Code]
length

[Code]
until <otherTaskId>

[Code]
otherTaskID

[Paragraph]
INFO

[Paragraph]
Support for keyword until was added in (v10.9.0+). This can be used to define a task which is running until some other specific task or milestone starts.

[Code]
until

[Paragraph]
For simplicity, the table does not show the use of multiple tasks listed with the after keyword. Here is an example of how to use it and how it's interpreted:

[Code]
after

[Code]
gantt
    apple :a, 2017-07-20, 1w
    banana :crit, b, 2017-07-23, 1d
    cherry :active, c, after b a, 1d
    kiwi   :d, 2017-07-20, until b c

[Paragraph]
The title is an optional string to be displayed at the top of the Gantt chart to describe the chart as a whole.

[Code]
title

[Paragraph]
The excludes is an optional attribute that accepts specific dates in YYYY-MM-DD format, days of the week ("sunday") or "weekends", but not the word "weekdays". These date will be marked on the graph, and be excluded from the duration calculation of tasks. Meaning that if there are excluded dates during a task interval, the number of 'skipped' days will be added to the end of the task to ensure the duration is as specified in the code.

[Code]
excludes

[Paragraph]
When excluding weekends, it is possible to configure the weekends to be either Friday and Saturday or Saturday and Sunday. By default weekends are Saturday and Sunday. To define the weekend start day, there is an optional attribute weekend that can be added in a new line followed by either friday or saturday.

[Code]
weekend

[Code]
friday

[Code]
saturday

[Code]
gantt
    title A Gantt Diagram Excluding Fri - Sat weekends
    dateFormat YYYY-MM-DD
    excludes weekends
    weekend friday
    section Section
        A task          :a1, 2024-01-01, 30d
        Another task    :after a1, 20d

[Paragraph]
You can divide the chart into various sections, for example to separate different parts of a project like development and documentation.

[Paragraph]
To do so, start a line with the section keyword and give it a name. (Note that unlike with the title for the entire chart, this name is required.

[Code]
section

[Paragraph]
You can add milestones to the diagrams. Milestones differ from tasks as they represent a single instant in time and are identified by the keyword milestone. Below is an example on how to use milestones. As you may notice, the exact location of the milestone is determined by the initial date for the milestone and the "duration" of the task this way: initial date+duration/2.

[Code]
milestone

[Code]
gantt
    dateFormat HH:mm
    axisFormat %H:%M
    Initial milestone : milestone, m1, 17:49, 2m
    Task A : 10m
    Task B : 5m
    Final milestone : milestone, m2, 18:08, 4m

[Paragraph]
The vert keyword lets you add vertical lines to your Gantt chart, making it easy to highlight important dates like deadlines, events, or checkpoints. These markers extend across the entire chart and are positioned based on the date you provide. Unlike milestones, vertical markers don’t take up a row. They’re purely visual reference points that help break up the timeline and make important moments easier to spot.

[Code]
vert

[Code]
gantt
    dateFormat HH:mm
    axisFormat %H:%M
    Initial vert : vert, v1, 17:30, 2m
    Task A : 3m
    Task B : 8m
    Final vert : vert, v2, 17:58, 4m

[Paragraph]
dateFormat defines the format of the date input of your gantt elements. How these dates are represented in the rendered chart output are defined by axisFormat.

[Code]
dateFormat

[Code]
axisFormat

[Paragraph]
The default input date format is YYYY-MM-DD. You can define your custom dateFormat.

[Code]
YYYY-MM-DD

[Code]
dateFormat

[Code]
dateFormat YYYY-MM-DD

[Paragraph]
The following formatting options are supported:

[Code]
YYYY

[Code]
YY

[Code]
Q

[Code]
M MM

[Code]
MMM MMMM

[Code]
dayjs.locale()

[Code]
D DD

[Code]
Do

[Code]
DDD DDDD

[Code]
X

[Code]
x

[Code]
H HH

[Code]
h hh

[Code]
a A

[Code]
a A

[Code]
m mm

[Code]
s ss

[Code]
S

[Code]
SS

[Code]
SSS

[Code]
Z ZZ

[Paragraph]
More info in: https://day.js.org/docs/en/parse/string-format/

[Paragraph]
The default output date format is YYYY-MM-DD. You can define your custom axisFormat, like 2020-Q1 for the first quarter of the year 2020.

[Code]
YYYY-MM-DD

[Code]
axisFormat

[Code]
2020-Q1

[Code]
axisFormat %Y-%m-%d

[Paragraph]
The following formatting strings are supported:

[Paragraph]
More info in: https://github.com/d3/d3-time-format/tree/v4.0.0#locale_format

[Paragraph]
The default output ticks are auto. You can custom your tickInterval, like 1day or 1week.

[Code]
tickInterval

[Code]
1day

[Code]
1week

[Code]
tickInterval 1day

[Paragraph]
The pattern is:

[Code]
/^([1-9][0-9]*)(millisecond|second|minute|hour|day|week|month)$/;

[Paragraph]
More info in: https://github.com/d3/d3-time#interval_every

[Paragraph]
Week-based tickIntervals start the week on sunday by default. If you wish to specify another weekday on which the tickInterval should start, use the weekday option:

[Code]
tickInterval

[Code]
tickInterval

[Code]
weekday

[Code]
gantt
  tickInterval 1week
  weekday monday

[Paragraph]
WARNING

[Paragraph]
millisecond and second support was added in v10.3.0

[Code]
millisecond

[Code]
second

[Paragraph]
The compact mode allows you to display multiple tasks in the same row. Compact mode can be enabled for a gantt chart by setting the display mode of the graph via preceding YAML settings.

[Code]
---
displayMode: compact
---
gantt
    title A Gantt Diagram
    dateFormat  YYYY-MM-DD

    section Section
    A task           :a1, 2014-01-01, 30d
    Another task     :a2, 2014-01-20, 25d
    Another one      :a3, 2014-02-10, 20d

[Paragraph]
Comments can be entered within a gantt chart, which will be ignored by the parser. Comments need to be on their own line and must be prefaced with %% (double percent signs). Any text after the start of the comment to the next newline will be treated as a comment, including any diagram syntax.

[Code]
%%

[Code]
gantt
    title A Gantt Diagram
    %% This is a comment
    dateFormat YYYY-MM-DD
    section Section
        A task          :a1, 2014-01-01, 30d
        Another task    :after a1, 20d
    section Another
        Task in Another :2014-01-12, 12d
        another task    :24d

[Paragraph]
Styling of the Gantt diagram is done by defining a number of CSS classes. During rendering, these classes are extracted from the file located at src/diagrams/gantt/styles.js

[Code]
.grid .tick {
  stroke: lightgrey;
  opacity: 0.3;
  shape-rendering: crispEdges;
}
.grid path {
  stroke-width: 0;
}

#tag {
  color: white;
  background: #fa283d;
  width: 150px;
  position: absolute;
  display: none;
  padding: 3px 6px;
  margin-left: -80px;
  font-size: 11px;
}

#tag:before {
  border: solid transparent;
  content: ' ';
  height: 0;
  left: 50%;
  margin-left: -5px;
  position: absolute;
  width: 0;
  border-width: 10px;
  border-bottom-color: #fa283d;
  top: -20px;
}
.taskText {
  fill: white;
  text-anchor: middle;
}
.taskTextOutsideRight {
  fill: black;
  text-anchor: start;
}
.taskTextOutsideLeft {
  fill: black;
  text-anchor: end;
}

[Paragraph]
You can style or hide the marker for the current date. To style it, add a value for the todayMarker key.

[Code]
todayMarker

[Code]
todayMarker stroke-width:5px,stroke:#0f0,opacity:0.5

[Paragraph]
To hide the marker, set todayMarker to off.

[Code]
todayMarker

[Code]
off

[Code]
todayMarker off

[Paragraph]
It is possible to adjust the margins for rendering the gantt diagram.

[Paragraph]
This is done by defining the ganttConfig part of the configuration object. How to use the CLI is described in the mermaidCLI page.

[Code]
ganttConfig

[Paragraph]
mermaid.ganttConfig can be set to a JSON string with config parameters or the corresponding object.

[Code]
mermaid.ganttConfig = {
  titleTopMargin: 25, // Margin top for the text over the diagram
  barHeight: 20, // The height of the bars in the graph
  barGap: 4, // The margin between the different activities in the gantt diagram
  topPadding: 75, // Margin between title and gantt diagram and between axis and gantt diagram.
  rightPadding: 75, // The space allocated for the section name to the right of the activities
  leftPadding: 75, // The space allocated for the section name to the left of the activities
  gridLineStartPadding: 10, // Vertical starting position of the grid lines
  fontSize: 12, // Font size
  sectionFontSize: 24, // Font size for sections
  numberSectionStyles: 1, // The number of alternating section styles
  axisFormat: '%d/%m', // Date/time format of the axis
  tickInterval: '1week', // Axis ticks
  topAxis: true, // When this flag is set, date labels will be added to the top of the chart
  displayMode: 'compact', // Turns compact mode on
  weekday: 'sunday', // On which day a week-based interval should start
};

[Paragraph]
It is possible to bind a click event to a task. The click can lead to either a javascript callback or to a link which will be opened in the current browser tab. Note: This functionality is disabled when using securityLevel='strict' and enabled when using securityLevel='loose'.

[Code]
securityLevel='strict'

[Code]
securityLevel='loose'

[Code]
click taskId call callback(arguments)
click taskId href URL

[Paragraph]
Beginner's tip—a full example using interactive links in an HTML context:

[Code]
<body>
  <pre class="mermaid">
    gantt
      dateFormat  YYYY-MM-DD

      section Clickable
      Visit mermaidjs         :active, cl1, 2014-01-07, 3d
      Print arguments         :cl2, after cl1, 3d
      Print task              :cl3, after cl2, 3d

      click cl1 href "https://mermaidjs.github.io/"
      click cl2 call printArguments("test1", "test2", test3)
      click cl3 call printTask()
  </pre>

  <script>
    const printArguments = function (arg1, arg2, arg3) {
      alert('printArguments called with arguments: ' + arg1 + ', ' + arg2 + ', ' + arg3);
    };
    const printTask = function (taskId) {
      alert('taskId: ' + taskId);
    };
    const config = {
      startOnLoad: true,
      securityLevel: 'loose',
    };
    mermaid.initialize(config);
  </script>
</body>

[Code]
gantt
    title Git Issues - days since last update
    dateFormat X
    axisFormat %s
    section Issue19062
    71   : 0, 71
    section Issue19401
    36   : 0, 36
    section Issue193
    34   : 0, 34
    section Issue7441
    9    : 0, 9
    section Issue1300
    5    : 0, 5

[Code]
---
    # Frontmatter config, YAML comments
    title: Ignored if specified in chart
    displayMode: compact     #gantt specific setting but works at this level too
    config:
#        theme: forest
#        themeCSS: " #item36 { fill: CadetBlue } "
        themeCSS: " // YAML supports multiline strings using a newline markers: \n
            #item36 { fill: CadetBlue }       \n

            // Custom marker workaround CSS from forum (below)    \n
            rect[id^=workaround] { height: calc(100% - 50px) ; transform: translate(9px, 25px); y: 0; width: 1.5px; stroke: none; fill: red; }   \n
            text[id^=workaround] { fill: red; y: 100%; font-size: 15px;}
        "
        gantt:
            useWidth: 400
            rightPadding: 0
            topAxis: true  #false
            numberSectionStyles: 2
---
gantt
    title Timeline - Gantt Sampler
    dateFormat YYYY
    axisFormat %y
    %% this next line doesn't recognise 'decade' or 'year', but will silently ignore
    tickInterval 1decade

    section Issue19062
    71   :            item71, 1900, 1930
    section Issue19401
    36   :            item36, 1913, 1935
    section Issue1300
    94   :            item94, 1910, 1915
    5    :            item5,  1920, 1925
    0    : milestone, item0,  1918, 1s
    9    : vert,              1906, 1s   %% not yet official
    64   : workaround,        1923, 1s   %% custom CSS object https://github.com/mermaid-js/mermaid/issues/3250



---  Page (https://mermaid.js.org/syntax/pie.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A pie chart (or a circle chart) is a circular statistical graphic, which is divided into slices to illustrate numerical proportion. In a pie chart, the arc length of each slice (and consequently its central angle and area), is proportional to the quantity it represents. While it is named for its resemblance to a pie which has been sliced, there are variations on the way it can be presented. The earliest known pie chart is generally credited to William Playfair's Statistical Breviary of 1801 -Wikipedia

[Paragraph]
Mermaid can render Pie Chart diagrams.

[Code]


[Paragraph]
Drawing a pie chart is really simple in mermaid.

[Code]
pie

[Code]
showData

[Code]
title

[Code]
label

[Code]
" "

[Code]
:

[Code]
positive numeric value

[Paragraph]
[pie] [showData] (OPTIONAL) [title] [titlevalue] (OPTIONAL) "[datakey1]" : [dataValue1] "[datakey2]" : [dataValue2] "[datakey3]" : [dataValue3] . .

[Code]


[Paragraph]
Possible pie diagram configuration parameters:

[Code]
textPosition

[Code]
0.75



---  Page (https://mermaid.js.org/syntax/quadrantChart.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A quadrant chart is a visual representation of data that is divided into four quadrants. It is used to plot data points on a two-dimensional grid, with one variable represented on the x-axis and another variable represented on the y-axis. The quadrants are determined by dividing the chart into four equal parts based on a set of criteria that is specific to the data being analyzed. Quadrant charts are often used to identify patterns and trends in data, and to prioritize actions based on the position of data points within the chart. They are commonly used in business, marketing, and risk management, among other fields.

[Code]


[Paragraph]
INFO

[Paragraph]
If there are no points available in the chart both axis text and quadrant will be rendered in the center of the respective quadrant. If there are points x-axis labels will rendered from the left of the respective quadrant also they will be displayed at the bottom of the chart, and y-axis labels will be rendered at the bottom of the respective quadrant, the quadrant text will render at the top of the respective quadrant.

[Paragraph]
INFO

[Paragraph]
For points x and y value min value is 0 and max value is 1.

[Paragraph]
The title is a short description of the chart and it will always render on top of the chart.

[Code]
quadrantChart
    title This is a sample example

[Paragraph]
The x-axis determines what text would be displayed in the x-axis. In x-axis there is two part left and right you can pass both or you can pass only left. The statement should start with x-axis then the left axis text followed by the delimiter --> then right axis text.

[Code]
x-axis

[Code]
left axis text

[Code]
-->

[Code]
right axis text

[Code]
x-axis <text> --> <text>

[Code]
x-axis <text>

[Paragraph]
The y-axis determines what text would be displayed in the y-axis. In y-axis there is two part top and bottom you can pass both or you can pass only bottom. The statement should start with y-axis then the bottom axis text followed by the delimiter --> then top axis text.

[Code]
y-axis

[Code]
bottom axis text

[Code]
-->

[Code]
top axis text

[Code]
y-axis <text> --> <text>

[Code]
y-axis <text>

[Paragraph]
The quadrant-[1,2,3,4] determine what text would be displayed inside the quadrants.

[Code]
quadrant-[1,2,3,4]

[Code]
quadrant-1 <text>

[Code]
quadrant-2 <text>

[Code]
quadrant-3 <text>

[Code]
quadrant-4 <text>

[Paragraph]
Points are used to plot a circle inside the quadrantChart. The syntax is <text>: [x, y] here x and y value is in the range 0 - 1.

[Code]
<text>: [x, y]

[Code]
Point 1: [0.75, 0.80]

[Code]
Point 2: [0.35, 0.24]

[Code]


[Paragraph]
Points can either be styled directly or with defined shared classes

[Code]
Point A: [0.9, 0.0] radius: 12
Point B: [0.8, 0.1] color: #ff3300, radius: 10
Point C: [0.7, 0.2] radius: 25, color: #00ff33, stroke-color: #10f0f0
Point D: [0.6, 0.3] radius: 15, stroke-color: #00ff0f, stroke-width: 5px ,color: #ff33f0

[Code]
Point A:::class1: [0.9, 0.0]
Point B:::class2: [0.8, 0.1]
Point C:::class3: [0.7, 0.2]
Point D:::class3: [0.7, 0.2]
classDef class1 color: #109060
classDef class2 color: #908342, radius : 10, stroke-color: #310085, stroke-width: 10px
classDef class3 color: #f00fff, radius : 10

[Paragraph]
INFO

[Paragraph]
Order of preference:

[Code]




---  Page (https://mermaid.js.org/syntax/requirementDiagram.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A Requirement diagram provides a visualization for requirements and their connections, to each other and other documented elements. The modeling specs follow those defined by SysML v1.6.

[Paragraph]
Rendering requirements is straightforward.

[Code]
requirementDiagram

    requirement test_req {
    id: 1
    text: the test text.
    risk: high
    verifymethod: test
    }

    element test_entity {
    type: simulation
    }

    test_entity - satisfies -> test_req

[Paragraph]
There are three types of components to a requirement diagram: requirement, element, and relationship.

[Paragraph]
The grammar for defining each is defined below. Words denoted in angle brackets, such as <word>, are enumerated keywords that have options elaborated in a table. user_defined_... is use in any place where user input is expected.

[Code]
<word>

[Code]
user_defined_...

[Paragraph]
An important note on user text: all input can be surrounded in quotes or not. For example, both id: "here is an example" and id: here is an example are both valid. However, users must be careful with unquoted input. The parser will fail if another keyword is detected.

[Code]
id: "here is an example"

[Code]
id: here is an example

[Paragraph]
A requirement definition contains a requirement type, name, id, text, risk, and verification method. The syntax follows:

[Code]
<type> user_defined_name {
    id: user_defined_id
    text: user_defined text
    risk: <risk>
    verifymethod: <method>
}

[Paragraph]
Type, risk, and method are enumerations defined in SysML.

[Paragraph]
An element definition contains an element name, type, and document reference. These three are all user defined. The element feature is intended to be lightweight but allow requirements to be connected to portions of other documents.

[Code]
element user_defined_name {
    type: user_defined_type
    docref: user_defined_ref
}

[Paragraph]
In places where user defined text is possible (like names, requirement text, element docref, etc.), you can:

[Code]
"example text"

[Code]
"**bold text** and *italics*"

[Paragraph]
Example:

[Code]
requirementDiagram

requirement "__test_req__" {
    id: 1
    text: "*italicized text* **bold text**"
    risk: high
    verifymethod: test
}

[Paragraph]
Relationships are comprised of a source node, destination node, and relationship type.

[Paragraph]
Each follows the definition format of

[Code]
{name of source} - <type> -> {name of destination}

[Paragraph]
or

[Code]
{name of destination} <- <type> - {name of source}

[Paragraph]
"name of source" and "name of destination" should be names of requirement or element nodes defined elsewhere.

[Paragraph]
A relationship type can be one of contains, copies, derives, satisfies, verifies, refines, or traces.

[Paragraph]
Each relationship is labeled in the diagram.

[Paragraph]
This example uses all features of the diagram.

[Code]
requirementDiagram

    requirement test_req {
    id: 1
    text: the test text.
    risk: high
    verifymethod: test
    }

    functionalRequirement test_req2 {
    id: 1.1
    text: the second test text.
    risk: low
    verifymethod: inspection
    }

    performanceRequirement test_req3 {
    id: 1.2
    text: the third test text.
    risk: medium
    verifymethod: demonstration
    }

    interfaceRequirement test_req4 {
    id: 1.2.1
    text: the fourth test text.
    risk: medium
    verifymethod: analysis
    }

    physicalRequirement test_req5 {
    id: 1.2.2
    text: the fifth test text.
    risk: medium
    verifymethod: analysis
    }

    designConstraint test_req6 {
    id: 1.2.3
    text: the sixth test text.
    risk: medium
    verifymethod: analysis
    }

    element test_entity {
    type: simulation
    }

    element test_entity2 {
    type: word doc
    docRef: reqs/test_entity
    }

    element test_entity3 {
    type: "test suite"
    docRef: github.com/all_the_tests
    }


    test_entity - satisfies -> test_req2
    test_req - traces -> test_req2
    test_req - contains -> test_req3
    test_req3 - contains -> test_req4
    test_req4 - derives -> test_req5
    test_req5 - refines -> test_req6
    test_entity3 - verifies -> test_req5
    test_req <- copies - test_entity2

[Paragraph]
The diagram can be rendered in different directions using the direction statement. Valid values are:

[Code]
direction

[Code]
TB

[Code]
BT

[Code]
LR

[Code]
RL

[Paragraph]
Example:

[Code]
requirementDiagram

direction LR

requirement test_req {
    id: 1
    text: the test text.
    risk: high
    verifymethod: test
}

element test_entity {
    type: simulation
}

test_entity - satisfies -> test_req

[Paragraph]
Requirements and elements can be styled using direct styling or classes. As a rule of thumb, when applying styles or classes, it accepts a list of requirement or element names and a list of class names allowing multiple assignments at a time (The only exception is the shorthand syntax ::: which can assign multiple classes but only to one requirement or element at a time).

[Code]
:::

[Paragraph]
Use the style keyword to apply CSS styles directly:

[Code]
style

[Code]
requirementDiagram

requirement test_req {
    id: 1
    text: styling example
    risk: low
    verifymethod: test
}

element test_entity {
    type: simulation
}

style test_req fill:#ffa,stroke:#000, color: green
style test_entity fill:#f9f,stroke:#333, color: blue

[Paragraph]
Define reusable styles using classDef:

[Code]
classDef

[Code]
requirementDiagram

requirement test_req {
    id: 1
    text: "class styling example"
    risk: low
    verifymethod: test
}

element test_entity {
    type: simulation
}

classDef important fill:#f96,stroke:#333,stroke-width:4px
classDef test fill:#ffa,stroke:#000

[Paragraph]
If a class is named default it will be applied to all nodes. Specific styles and classes should be defined afterwards to override the applied default styling.

[Code]
classDef default fill:#f9f,stroke:#333,stroke-width:4px;

[Paragraph]
Classes can be applied in two ways:

[Code]
class

[Code]
class test_req,test_entity important

[Code]
:::

[Code]
requirement test_req:::important {
    id: 1
    text: class styling example
    risk: low
    verifymethod: test
}

[Code]
element test_elem {
}

test_elem:::myClass

[Code]
requirementDiagram

requirement test_req:::important {
    id: 1
    text: "class styling example"
    risk: low
    verifymethod: test
}

element test_entity {
    type: simulation
}

classDef important font-weight:bold

class test_entity important
style test_entity fill:#f9f,stroke:#333



---  Page (https://mermaid.js.org/syntax/gitgraph.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A Git Graph is a pictorial representation of git commits and git actions(commands) on various branches.

[Paragraph]
These kind of diagram are particularly helpful to developers and devops teams to share their Git branching strategies. For example, it makes it easier to visualize how git flow works.

[Paragraph]
Mermaid can render Git diagrams

[Code]


[Paragraph]
In Mermaid, we support the basic git operations like:

[Paragraph]
With the help of these key git commands, you will be able to draw a gitgraph in Mermaid very easily and quickly. Entity names are often capitalized, although there is no accepted standard on this, and it is not required in Mermaid.

[Paragraph]
NOTE: checkout and switch can be used interchangeably.

[Code]
checkout

[Code]
switch

[Paragraph]
Mermaid syntax for a gitgraph is very straight-forward and simple. It follows a declarative-approach, where each commit is drawn on the timeline in the diagram, in order of its occurrences/presence in code. Basically, it follows the insertion order for each command.

[Paragraph]
First thing you do is to declare your diagram type using the gitgraph keyword. This gitgraph keyword, tells Mermaid that you wish to draw a gitgraph, and parse the diagram code accordingly.

[Code]
gitgraph

[Paragraph]
Each gitgraph, is initialized with main branch. So unless you create a different branch, by-default the commits will go to the main branch. This is driven with how git works, where in the beginning you always start with the main branch (formerly called as master branch). And by-default, main branch is set as your current branch.

[Code]
main

[Paragraph]
You make use of commit keyword to register a commit on the current branch. Let see how this works:

[Paragraph]
A simple gitgraph showing three commits on the default (main) branch:

[Code]


[Paragraph]
If you look closely at the previous example, you can see the default branch main along with three commits. Also, notice that by default each commit has been given a unique & random ID. What if you wanted to give your own custom ID to a commit? Yes, it is possible to do that with Mermaid.

[Code]
main

[Paragraph]
For a given commit you may specify a custom ID at the time of declaring it using the id attribute, followed by : and your custom value within a "" quote. For example: commit id: "your_custom_id"

[Code]
id

[Code]
:

[Code]
""

[Code]
commit id: "your_custom_id"

[Paragraph]
Let us see how this works with the help of the following diagram:

[Code]


[Paragraph]
In this example, we have given our custom IDs to the commits.

[Paragraph]
In Mermaid, a commit can be of three type, which render a bit different in the diagram. These types are:

[Code]
NORMAL

[Code]
REVERSE

[Code]
HIGHLIGHT

[Paragraph]
For a given commit you may specify its type at the time of declaring it using the type attribute, followed by : and the required type option discussed above. For example: commit type: HIGHLIGHT

[Code]
type

[Code]
:

[Code]
commit type: HIGHLIGHT

[Paragraph]
NOTE: If no commit type is specified, NORMAL is picked as default.

[Code]
NORMAL

[Paragraph]
Let us see how these different commit type look with the help of the following diagram:

[Code]


[Paragraph]
In this example, we have specified different types to each commit. Also, see how we have included both id and type together at the time of declaring our commits.

[Code]
id

[Code]
type

[Paragraph]
For a given commit you may decorate it as a tag, similar to the concept of tags or release version in git world. You can attach a custom tag at the time of declaring a commit using the tag attribute, followed by : and your custom value within "" quote. For example: commit tag: "your_custom_tag"

[Code]
tag

[Code]
:

[Code]
""

[Code]
commit tag: "your_custom_tag"

[Paragraph]
Let us see how this works with the help of the following diagram:

[Code]


[Paragraph]
In this example, we have given custom tags to the commits. Also, see how we have combined all these attributes in a single commit declaration. You can mix-match these attributes as you like.

[Paragraph]
In Mermaid, in-order to create a new branch, you make use of the branch keyword. You also need to provide a name of the new branch. The name has to be unique and cannot be that of an existing branch. A branch name that could be confused for a keyword must be quoted within "". Usage examples: branch develop, branch "cherry-pick"

[Code]
branch

[Code]
""

[Code]
branch develop

[Code]
branch "cherry-pick"

[Paragraph]
When Mermaid, reads the branch keyword, it creates a new branch and sets it as the current branch. Equivalent to you creating a new branch and checking it out in Git world.

[Code]
branch

[Paragraph]
Let see this in an example:

[Code]


[Paragraph]
In this example, see how we started with default main branch, and pushed two commits on that. Then we created the develop branch, and all commits afterwards are put on the develop branch as it became the current branch.

[Code]
main

[Code]
develop

[Code]
develop

[Paragraph]
In Mermaid, in order to switch to an existing branch, you make use of the checkout keyword. You also need to provide a name of an existing branch. If no branch is found with the given name, it will result in console error. Usage example: checkout develop

[Code]
checkout

[Code]
checkout develop

[Paragraph]
When Mermaid, reads the checkout keyword, it finds the given branch and sets it as the current branch. Equivalent to checking out a branch in the Git world.

[Code]
checkout

[Paragraph]
Let see modify our previous example:

[Code]


[Paragraph]
In this example, see how we started with default main branch, and pushed two commits on that. Then we created the develop branch, and all three commits afterwards are put on the develop branch as it became the current branch. After this we made use of the checkout keyword to set the current branch as main, and all commit that follow are registered against the current branch, i.e. main.

[Code]
main

[Code]
develop

[Code]
develop

[Code]
checkout

[Code]
main

[Code]
main

[Paragraph]
In Mermaid, in order to merge or join to an existing branch, you make use of the merge keyword. You also need to provide the name of an existing branch to merge from. If no branch is found with the given name, it will result in console error. Also, you can only merge two separate branches, and cannot merge a branch with itself. In such case an error is throw.

[Code]
merge

[Paragraph]
Usage example: merge develop

[Code]
merge develop

[Paragraph]
When Mermaid, reads the merge keyword, it finds the given branch and its head commit (the last commit on that branch), and joins it with the head commit on the current branch. Each merge results in a merge commit, represented in the diagram with filled double circle.

[Code]
merge

[Paragraph]
Let us modify our previous example to merge our two branches:

[Code]


[Paragraph]
In this example, see how we started with default main branch, and pushed two commits on that. Then we created the develop branch, and all three commits afterwards are put on the develop branch as it became the current branch. After this we made use of the checkout keyword to set the current branch as main, and all commits that follow are registered against the current branch, i.e. main. After this we merge the develop branch onto the current branch main, resulting in a merge commit. Since the current branch at this point is still main, the last two commits are registered against that.

[Code]
main

[Code]
develop

[Code]
develop

[Code]
checkout

[Code]
main

[Code]
main

[Code]
develop

[Code]
main

[Code]
main

[Paragraph]
You can also decorate your merge with similar attributes as you did for the commit using:

[Code]
id

[Code]
tag

[Code]
type

[Paragraph]
And you can choose to use none, some or all of these attributes together. For example: merge develop id: "my_custom_id" tag: "my_custom_tag" type: REVERSE

[Code]
merge develop id: "my_custom_id" tag: "my_custom_tag" type: REVERSE

[Paragraph]
Let us see how this works with the help of the following diagram:

[Code]


[Paragraph]
Similar to how 'git' allows you to cherry-pick a commit from another branch onto the current branch, Mermaid also supports this functionality. You can also cherry-pick a commit from another branch using the cherry-pick keyword.

[Code]
cherry-pick

[Paragraph]
To use the cherry-pick keyword, you must specify the id using the id attribute, followed by : and your desired commit id within a "" quote. For example:

[Code]
cherry-pick

[Code]
id

[Code]
:

[Code]
""

[Paragraph]
cherry-pick id: "your_custom_id"

[Code]
cherry-pick id: "your_custom_id"

[Paragraph]
Here, a new commit representing the cherry-pick is created on the current branch, and is visually highlighted in the diagram with a cherry and a tag depicting the commit id from which it is cherry-picked from.

[Paragraph]
A few important rules to note here are:

[Code]
id

[Code]
commit id:$value

[Paragraph]
Let see an example:

[Code]


[Paragraph]
In Mermaid, you have the option to configure the gitgraph diagram. You can configure the following options:

[Code]
showBranches

[Code]
true

[Code]
false

[Code]
showCommitLabel

[Code]
true

[Code]
false

[Code]
mainBranchName

[Code]
main

[Code]
mainBranchOrder

[Code]
0

[Code]
main

[Code]
parallelCommits

[Code]
false

[Code]
true

[Paragraph]
Let's look at them one by one.

[Paragraph]
Sometimes you may want to hide the branch names and lines from the diagram. You can do this by using the showBranches keyword. By default its value is true. You can set it to false using directives.

[Code]
showBranches

[Code]
true

[Code]
false

[Paragraph]
Usage example:

[Code]


[Paragraph]
Mermaid supports two types of commit labels layout. The default layout is rotated, which means the labels are placed below the commit circle, rotated at 45 degrees for better readability. This is particularly useful for commits with long labels.

[Paragraph]
The other option is horizontal, which means the labels are placed below the commit circle centred horizontally, and are not rotated. This is particularly useful for commits with short labels.

[Paragraph]
You can change the layout of the commit labels by using the rotateCommitLabel keyword in the directive. It defaults to true, which means the commit labels are rotated.

[Code]
rotateCommitLabel

[Code]
true

[Paragraph]
Usage example: Rotated commit labels

[Code]


[Paragraph]
Usage example: Horizontal commit labels

[Code]


[Paragraph]
Sometimes you may want to hide the commit labels from the diagram. You can do this by using the showCommitLabel keyword. By default its value is true. You can set it to false using directives.

[Code]
showCommitLabel

[Code]
true

[Code]
false

[Paragraph]
Usage example:

[Code]


[Paragraph]
Sometimes you may want to customize the name of the main/default branch. You can do this by using the mainBranchName keyword. By default its value is main. You can set it to any string using directives.

[Code]
mainBranchName

[Code]
main

[Paragraph]
Usage example:

[Code]


[Paragraph]
Look at the imaginary railroad map created using Mermaid. Here, we have changed the default main branch name to MetroLine1.

[Code]
MetroLine1

[Paragraph]
In Mermaid, by default the branches are shown in the order of their definition or appearance in the diagram code.

[Paragraph]
Sometimes you may want to customize the order of the branches. You can do this by using the order keyword next the branch definition. You can set it to a positive number.

[Code]
order

[Paragraph]
Mermaid follows the given precedence order of the order keyword.

[Code]
order

[Code]
0

[Code]
0

[Code]
mainBranchOrder

[Code]
order

[Code]
order

[Code]
order

[Paragraph]
To fully control the order of all the branches, you must define order for all the branches.

[Code]
order

[Paragraph]
Usage example:

[Code]


[Paragraph]
Look at the diagram, all the branches are following the order defined.

[Paragraph]
Usage example:

[Code]


[Paragraph]
Look at the diagram, here, all the branches without a specified order are drawn in their order of definition. Then, test4 branch is drawn because the order of 1. Then, main branch is drawn because the order of 2. And, lastly test1is drawn because the order of 3.

[Code]
test4

[Code]
1

[Code]
main

[Code]
2

[Code]
test1

[Code]
3

[Paragraph]
NOTE: Because we have overridden the mainBranchOrder to 2, the main branch is not drawn in the beginning, instead follows the ordering.

[Code]
mainBranchOrder

[Code]
2

[Code]
main

[Paragraph]
Here, we have changed the default main branch name to MetroLine1.

[Code]
MetroLine1

[Paragraph]
Mermaid supports three graph orientations: Left-to-Right (default), Top-to-Bottom, and Bottom-to-Top.

[Paragraph]
You can set this with either LR: (for Left-to-Right), TB: (for Top-to-Bottom) or BT: (for Bottom-to-Top) after gitGraph.

[Code]
LR:

[Code]
TB:

[Code]
BT:

[Code]
gitGraph

[Code]
LR:

[Paragraph]
In Mermaid, the default orientation is for commits to run from left to right and for branches to be stacked on top of one another.

[Paragraph]
However, you can set this explicitly with LR: after gitGraph.

[Code]
LR:

[Code]
gitGraph

[Paragraph]
Usage example:

[Code]


[Code]
TB:

[Paragraph]
In TB (Top-to-Bottom) orientation, the commits run from top to bottom of the graph and branches are arranged side-by-side.

[Code]
TB

[Paragraph]
To orient the graph this way, you need to add TB: after gitGraph.

[Code]
TB:

[Paragraph]
Usage example:

[Code]


[Code]
BT:

[Paragraph]
In BT (Bottom-to-Top) orientation, the commits run from bottom to top of the graph and branches are arranged side-by-side.

[Code]
BT

[Paragraph]
To orient the graph this way, you need to add BT: after gitGraph.

[Code]
BT:

[Paragraph]
Usage example:

[Code]


[Paragraph]
Commits in Mermaid display temporal information in gitgraph by default. For example if two commits are one commit away from its parent, the commit that was made earlier is rendered closer to its parent. You can turn this off by enabling the parallelCommits flag.

[Code]
parallelCommits

[Code]
parallelCommits: false

[Code]


[Code]
parallelCommits: true

[Code]


[Paragraph]
Mermaid supports a bunch of pre-defined themes which you can use to find the right one for you. PS: you can actually override an existing theme's variable to get your own custom theme going. Learn more about theming your diagram.

[Paragraph]
The following are the different pre-defined theme options:

[Code]
base

[Code]
forest

[Code]
dark

[Code]
default

[Code]
neutral

[Paragraph]
NOTE: To change theme you can either use the initialize call or directives. Learn more about directives Let's put them to use, and see how our sample diagram looks in different themes:

[Code]
initialize

[Code]


[Code]


[Code]


[Code]


[Code]


[Paragraph]
Mermaid allows you to customize your diagram using theme variables which govern the look and feel of various elements of the diagram.

[Paragraph]
For understanding let us take a sample diagram with theme default, the default values of the theme variables is picked automatically from the theme. Later on we will see how to override the default values of the theme variables.

[Code]
default

[Paragraph]
See how the default theme is used to set the colors for the branches:

[Code]


[Paragraph]
Mermaid supports the theme variables to override the default values for up to 8 branches, i.e., you can set the color/styling of up to 8 branches using theme variables. After this threshold of 8 branches, the theme variables are reused in the cyclic manner, i.e. the 9th branch will use the color/styling of the 1st branch, or the branch at index position '8' will use the color/styling of the branch at index position '0'. More on this in the next section. See examples on Customizing branch label colors below

[Paragraph]
You can customize the branch colors using the git0 to git7 theme variables. Mermaid allows you to set the colors for up-to 8 branches, where git0 variable will drive the value of the first branch, git1 will drive the value of the second branch and so on.

[Code]
git0

[Code]
git7

[Code]
git0

[Code]
git1

[Paragraph]
NOTE: Default values for these theme variables are picked from the selected theme. If you want to override the default values, you can use the initialize call to add your custom theme variable values.

[Code]
initialize

[Paragraph]
Example:

[Paragraph]
Now let's override the default values for the git0 to git3 variables:

[Code]
git0

[Code]
git3

[Code]


[Paragraph]
See how the branch colors are changed to the values specified in the theme variables.

[Paragraph]
You can customize the branch label colors using the gitBranchLabel0 to gitBranchLabel7 theme variables. Mermaid allows you to set the colors for up-to 8 branches, where gitBranchLabel0 variable will drive the value of the first branch label, gitBranchLabel1 will drive the value of the second branch label and so on.

[Code]
gitBranchLabel0

[Code]
gitBranchLabel7

[Code]
gitBranchLabel0

[Code]
gitBranchLabel1

[Paragraph]
Lets see how the default theme is used to set the colors for the branch labels:

[Paragraph]
Now let's override the default values for the gitBranchLabel0 to gitBranchLabel2 variables:

[Code]
gitBranchLabel0

[Code]
gitBranchLabel2

[Code]


[Paragraph]
Here, you can see that branch8 and branch9 colors and the styles are being picked from branch at index position 0 (main) and 1(branch1) respectively, i.e., branch themeVariables are repeated cyclically.

[Code]
branch8

[Code]
branch9

[Code]
0

[Code]
main

[Code]
1

[Code]
branch1

[Paragraph]
You can customize commit using the commitLabelColor and commitLabelBackground theme variables for changes in the commit label color and background color respectively.

[Code]
commitLabelColor

[Code]
commitLabelBackground

[Paragraph]
Example: Now let's override the default values for the commitLabelColor to commitLabelBackground variables:

[Code]
commitLabelColor

[Code]
commitLabelBackground

[Code]


[Paragraph]
See how the commit label color and background color are changed to the values specified in the theme variables.

[Paragraph]
You can customize commit using the commitLabelFontSize theme variables for changing in the font size of the commit label .

[Code]
commitLabelFontSize

[Paragraph]
Example: Now let's override the default values for the commitLabelFontSize variable:

[Code]
commitLabelFontSize

[Code]


[Paragraph]
See how the commit label font size changed.

[Paragraph]
You can customize commit using the tagLabelFontSize theme variables for changing in the font size of the tag label .

[Code]
tagLabelFontSize

[Paragraph]
Example: Now let's override the default values for the tagLabelFontSize variable:

[Code]
tagLabelFontSize

[Code]


[Paragraph]
See how the tag label font size changed.

[Paragraph]
You can customize tag using the tagLabelColor,tagLabelBackground and tagLabelBorder theme variables for changes in the tag label color,tag label background color and tag label border respectively. Example: Now let's override the default values for the tagLabelColor, tagLabelBackground and to tagLabelBorder variables:

[Code]
tagLabelColor

[Code]
tagLabelBackground

[Code]
tagLabelBorder

[Code]
tagLabelColor

[Code]
tagLabelBackground

[Code]
tagLabelBorder

[Code]


[Paragraph]
See how the tag colors are changed to the values specified in the theme variables.

[Paragraph]
You can customize the highlight commit colors in relation to the branch it is on using the gitInv0 to gitInv7 theme variables. Mermaid allows you to set the colors for up-to 8 branches specific highlight commit, where gitInv0 variable will drive the value of the first branch's highlight commits, gitInv1 will drive the value of the second branch's highlight commit label and so on.

[Code]
gitInv0

[Code]
gitInv7

[Code]
gitInv0

[Code]
gitInv1

[Paragraph]
Example:

[Paragraph]
Now let's override the default values for the git0 to git3 variables:

[Code]
git0

[Code]
git3

[Code]


[Paragraph]
See how the highlighted commit color on the first branch is changed to the value specified in the theme variable gitInv0.

[Code]
gitInv0



---  Page (https://mermaid.js.org/syntax/c4.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
C4 Diagram: This is an experimental diagram for now. The syntax and properties can change in future releases. Proper documentation will be provided when the syntax is stable.

[Paragraph]
Mermaid's C4 diagram syntax is compatible with plantUML. See example below:

[Code]
C4Context
      title System Context diagram for Internet Banking System
      Enterprise_Boundary(b0, "BankBoundary0") {
        Person(customerA, "Banking Customer A", "A customer of the bank, with personal bank accounts.")
        Person(customerB, "Banking Customer B")
        Person_Ext(customerC, "Banking Customer C", "desc")

        Person(customerD, "Banking Customer D", "A customer of the bank, <br/> with personal bank accounts.")

        System(SystemAA, "Internet Banking System", "Allows customers to view information about their bank accounts, and make payments.")

        Enterprise_Boundary(b1, "BankBoundary") {

          SystemDb_Ext(SystemE, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")

          System_Boundary(b2, "BankBoundary2") {
            System(SystemA, "Banking System A")
            System(SystemB, "Banking System B", "A system of the bank, with personal bank accounts. next line.")
          }

          System_Ext(SystemC, "E-mail system", "The internal Microsoft Exchange e-mail system.")
          SystemDb(SystemD, "Banking System D Database", "A system of the bank, with personal bank accounts.")

          Boundary(b3, "BankBoundary3", "boundary") {
            SystemQueue(SystemF, "Banking System F Queue", "A system of the bank.")
            SystemQueue_Ext(SystemG, "Banking System G Queue", "A system of the bank, with personal bank accounts.")
          }
        }
      }

      BiRel(customerA, SystemAA, "Uses")
      BiRel(SystemAA, SystemE, "Uses")
      Rel(SystemAA, SystemC, "Sends e-mails", "SMTP")
      Rel(SystemC, customerA, "Sends e-mails to")

      UpdateElementStyle(customerA, $fontColor="red", $bgColor="grey", $borderColor="red")
      UpdateRelStyle(customerA, SystemAA, $textColor="blue", $lineColor="blue", $offsetX="5")
      UpdateRelStyle(SystemAA, SystemE, $textColor="blue", $lineColor="blue", $offsetY="-10")
      UpdateRelStyle(SystemAA, SystemC, $textColor="blue", $lineColor="blue", $offsetY="-40", $offsetX="-50")
      UpdateRelStyle(SystemC, customerA, $textColor="red", $lineColor="red", $offsetX="-50", $offsetY="20")

      UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")

[Paragraph]
For an example, see the source code demos/index.html

[Paragraph]
5 types of C4 charts are supported.

[Paragraph]
Please refer to the linked document C4-PlantUML syntax for how to write the C4 diagram.

[Paragraph]
C4 diagram is fixed style, such as css color, so different css is not provided under different skins. updateElementStyle and UpdateElementStyle are written in the diagram last part. updateElementStyle is inconsistent with the original definition and updates the style of the relationship, including the offset of the text label relative to the original position.

[Paragraph]
The layout does not use a fully automated layout algorithm. The position of shapes is adjusted by changing the order in which statements are written. So there is no plan to support the following Layout statements. The number of shapes per row and the number of boundaries can be adjusted using UpdateLayoutConfig.

[Paragraph]
The following unfinished features are not supported in the short term.

[Paragraph]
[ ] sprite

[Paragraph]
[ ] tags

[Paragraph]
[ ] link

[Paragraph]
[ ] Legend

[Paragraph]
[x] System Context

[Paragraph]
[x] Container diagram

[Paragraph]
[x] Component diagram

[Paragraph]
[x] Dynamic diagram

[Paragraph]
[x] Deployment diagram

[Paragraph]
[x] Relationship Types

[Paragraph]
[ ] Custom tags/stereotypes support and skin param updates

[Paragraph]
There are two ways to assign parameters with question marks. One uses the non-named parameter assignment method in the order of the parameters, and the other uses the named parameter assignment method, where the name must start with a $ symbol.

[Paragraph]
Example: UpdateRelStyle(from, to, ?textColor, ?lineColor, ?offsetX, ?offsetY)

[Code]
UpdateRelStyle(customerA, bankA, "red", "blue", "-40", "60")
UpdateRelStyle(customerA, bankA, $offsetX="-40", $offsetY="60", $lineColor="blue", $textColor="red")
UpdateRelStyle(customerA, bankA, $offsetY="60")

[Code]
C4Context
      title System Context diagram for Internet Banking System
      Enterprise_Boundary(b0, "BankBoundary0") {
        Person(customerA, "Banking Customer A", "A customer of the bank, with personal bank accounts.")
        Person(customerB, "Banking Customer B")
        Person_Ext(customerC, "Banking Customer C", "desc")

        Person(customerD, "Banking Customer D", "A customer of the bank, <br/> with personal bank accounts.")

        System(SystemAA, "Internet Banking System", "Allows customers to view information about their bank accounts, and make payments.")

        Enterprise_Boundary(b1, "BankBoundary") {

          SystemDb_Ext(SystemE, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")

          System_Boundary(b2, "BankBoundary2") {
            System(SystemA, "Banking System A")
            System(SystemB, "Banking System B", "A system of the bank, with personal bank accounts. next line.")
          }

          System_Ext(SystemC, "E-mail system", "The internal Microsoft Exchange e-mail system.")
          SystemDb(SystemD, "Banking System D Database", "A system of the bank, with personal bank accounts.")

          Boundary(b3, "BankBoundary3", "boundary") {
            SystemQueue(SystemF, "Banking System F Queue", "A system of the bank.")
            SystemQueue_Ext(SystemG, "Banking System G Queue", "A system of the bank, with personal bank accounts.")
          }
        }
      }

      BiRel(customerA, SystemAA, "Uses")
      BiRel(SystemAA, SystemE, "Uses")
      Rel(SystemAA, SystemC, "Sends e-mails", "SMTP")
      Rel(SystemC, customerA, "Sends e-mails to")

      UpdateElementStyle(customerA, $fontColor="red", $bgColor="grey", $borderColor="red")
      UpdateRelStyle(customerA, SystemAA, $textColor="blue", $lineColor="blue", $offsetX="5")
      UpdateRelStyle(SystemAA, SystemE, $textColor="blue", $lineColor="blue", $offsetY="-10")
      UpdateRelStyle(SystemAA, SystemC, $textColor="blue", $lineColor="blue", $offsetY="-40", $offsetX="-50")
      UpdateRelStyle(SystemC, customerA, $textColor="red", $lineColor="red", $offsetX="-50", $offsetY="20")

      UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")

[Code]
C4Container
    title Container diagram for Internet Banking System

    System_Ext(email_system, "E-Mail System", "The internal Microsoft Exchange system", $tags="v1.0")
    Person(customer, Customer, "A customer of the bank, with personal bank accounts", $tags="v1.0")

    Container_Boundary(c1, "Internet Banking") {
        Container(spa, "Single-Page App", "JavaScript, Angular", "Provides all the Internet banking functionality to customers via their web browser")
        Container_Ext(mobile_app, "Mobile App", "C#, Xamarin", "Provides a limited subset of the Internet banking functionality to customers via their mobile device")
        Container(web_app, "Web Application", "Java, Spring MVC", "Delivers the static content and the Internet banking SPA")
        ContainerDb(database, "Database", "SQL Database", "Stores user registration information, hashed auth credentials, access logs, etc.")
        ContainerDb_Ext(backend_api, "API Application", "Java, Docker Container", "Provides Internet banking functionality via API")

    }

    System_Ext(banking_system, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")

    Rel(customer, web_app, "Uses", "HTTPS")
    UpdateRelStyle(customer, web_app, $offsetY="60", $offsetX="90")
    Rel(customer, spa, "Uses", "HTTPS")
    UpdateRelStyle(customer, spa, $offsetY="-40")
    Rel(customer, mobile_app, "Uses")
    UpdateRelStyle(customer, mobile_app, $offsetY="-30")

    Rel(web_app, spa, "Delivers")
    UpdateRelStyle(web_app, spa, $offsetX="130")
    Rel(spa, backend_api, "Uses", "async, JSON/HTTPS")
    Rel(mobile_app, backend_api, "Uses", "async, JSON/HTTPS")
    Rel_Back(database, backend_api, "Reads from and writes to", "sync, JDBC")

    Rel(email_system, customer, "Sends e-mails to")
    UpdateRelStyle(email_system, customer, $offsetX="-45")
    Rel(backend_api, email_system, "Sends e-mails using", "sync, SMTP")
    UpdateRelStyle(backend_api, email_system, $offsetY="-60")
    Rel(backend_api, banking_system, "Uses", "sync/async, XML/HTTPS")
    UpdateRelStyle(backend_api, banking_system, $offsetY="-50", $offsetX="-140")

[Code]
C4Component
    title Component diagram for Internet Banking System - API Application

    Container(spa, "Single Page Application", "javascript and angular", "Provides all the internet banking functionality to customers via their web browser.")
    Container(ma, "Mobile App", "Xamarin", "Provides a limited subset to the internet banking functionality to customers via their mobile device.")
    ContainerDb(db, "Database", "Relational Database Schema", "Stores user registration information, hashed authentication credentials, access logs, etc.")
    System_Ext(mbs, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")

    Container_Boundary(api, "API Application") {
        Component(sign, "Sign In Controller", "MVC Rest Controller", "Allows users to sign in to the internet banking system")
        Component(accounts, "Accounts Summary Controller", "MVC Rest Controller", "Provides customers with a summary of their bank accounts")
        Component(security, "Security Component", "Spring Bean", "Provides functionality related to singing in, changing passwords, etc.")
        Component(mbsfacade, "Mainframe Banking System Facade", "Spring Bean", "A facade onto the mainframe banking system.")

        Rel(sign, security, "Uses")
        Rel(accounts, mbsfacade, "Uses")
        Rel(security, db, "Read & write to", "JDBC")
        Rel(mbsfacade, mbs, "Uses", "XML/HTTPS")
    }

    Rel_Back(spa, sign, "Uses", "JSON/HTTPS")
    Rel(spa, accounts, "Uses", "JSON/HTTPS")

    Rel(ma, sign, "Uses", "JSON/HTTPS")
    Rel(ma, accounts, "Uses", "JSON/HTTPS")

    UpdateRelStyle(spa, sign, $offsetY="-40")
    UpdateRelStyle(spa, accounts, $offsetX="40", $offsetY="40")

    UpdateRelStyle(ma, sign, $offsetX="-90", $offsetY="40")
    UpdateRelStyle(ma, accounts, $offsetY="-40")

        UpdateRelStyle(sign, security, $offsetX="-160", $offsetY="10")
        UpdateRelStyle(accounts, mbsfacade, $offsetX="140", $offsetY="10")
        UpdateRelStyle(security, db, $offsetY="-40")
        UpdateRelStyle(mbsfacade, mbs, $offsetY="-40")

[Code]
C4Dynamic
    title Dynamic diagram for Internet Banking System - API Application

    ContainerDb(c4, "Database", "Relational Database Schema", "Stores user registration information, hashed authentication credentials, access logs, etc.")
    Container(c1, "Single-Page Application", "JavaScript and Angular", "Provides all of the Internet banking functionality to customers via their web browser.")
    Container_Boundary(b, "API Application") {
      Component(c3, "Security Component", "Spring Bean", "Provides functionality Related to signing in, changing passwords, etc.")
      Component(c2, "Sign In Controller", "Spring MVC Rest Controller", "Allows users to sign in to the Internet Banking System.")
    }
    Rel(c1, c2, "Submits credentials to", "JSON/HTTPS")
    Rel(c2, c3, "Calls isAuthenticated() on")
    Rel(c3, c4, "select * from users where username = ?", "JDBC")

    UpdateRelStyle(c1, c2, $textColor="red", $offsetY="-40")
    UpdateRelStyle(c2, c3, $textColor="red", $offsetX="-40", $offsetY="60")
    UpdateRelStyle(c3, c4, $textColor="red", $offsetY="-40", $offsetX="10")

[Code]
C4Deployment
    title Deployment Diagram for Internet Banking System - Live

    Deployment_Node(mob, "Customer's mobile device", "Apple IOS or Android"){
        Container(mobile, "Mobile App", "Xamarin", "Provides a limited subset of the Internet Banking functionality to customers via their mobile device.")
    }

    Deployment_Node(comp, "Customer's computer", "Microsoft Windows or Apple macOS"){
        Deployment_Node(browser, "Web Browser", "Google Chrome, Mozilla Firefox,<br/> Apple Safari or Microsoft Edge"){
            Container(spa, "Single Page Application", "JavaScript and Angular", "Provides all of the Internet Banking functionality to customers via their web browser.")
        }
    }

    Deployment_Node(plc, "Big Bank plc", "Big Bank plc data center"){
        Deployment_Node(dn, "bigbank-api*** x8", "Ubuntu 16.04 LTS"){
            Deployment_Node(apache, "Apache Tomcat", "Apache Tomcat 8.x"){
                Container(api, "API Application", "Java and Spring MVC", "Provides Internet Banking functionality via a JSON/HTTPS API.")
            }
        }
        Deployment_Node(bb2, "bigbank-web*** x4", "Ubuntu 16.04 LTS"){
            Deployment_Node(apache2, "Apache Tomcat", "Apache Tomcat 8.x"){
                Container(web, "Web Application", "Java and Spring MVC", "Delivers the static content and the Internet Banking single page application.")
            }
        }
        Deployment_Node(bigbankdb01, "bigbank-db01", "Ubuntu 16.04 LTS"){
            Deployment_Node(oracle, "Oracle - Primary", "Oracle 12c"){
                ContainerDb(db, "Database", "Relational Database Schema", "Stores user registration information, hashed authentication credentials, access logs, etc.")
            }
        }
        Deployment_Node(bigbankdb02, "bigbank-db02", "Ubuntu 16.04 LTS") {
            Deployment_Node(oracle2, "Oracle - Secondary", "Oracle 12c") {
                ContainerDb(db2, "Database", "Relational Database Schema", "Stores user registration information, hashed authentication credentials, access logs, etc.")
            }
        }
    }

    Rel(mobile, api, "Makes API calls to", "json/HTTPS")
    Rel(spa, api, "Makes API calls to", "json/HTTPS")
    Rel_U(web, spa, "Delivers to the customer's web browser")
    Rel(api, db, "Reads from and writes to", "JDBC")
    Rel(api, db2, "Reads from and writes to", "JDBC")
    Rel_R(db, db2, "Replicates data to")

    UpdateRelStyle(spa, api, $offsetY="-40")
    UpdateRelStyle(web, spa, $offsetY="-40")
    UpdateRelStyle(api, db, $offsetY="-20", $offsetX="5")
    UpdateRelStyle(api, db2, $offsetX="-40", $offsetY="-20")
    UpdateRelStyle(db, db2, $offsetY="-10")



---  Page (https://mermaid.js.org/syntax/mindmap.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
Mindmap: This is an experimental diagram for now. The syntax and properties can change in future releases. The syntax is stable except for the icon integration which is the experimental part.

[Paragraph]
"A mind map is a diagram used to visually organize information into a hierarchy, showing relationships among pieces of the whole. It is often created around a single concept, drawn as an image in the center of a blank page, to which associated representations of ideas such as images, words and parts of words are added. Major ideas are connected directly to the central concept, and other ideas branch out from those major ideas." Wikipedia

[Code]


[Paragraph]
The syntax for creating Mindmaps is simple and relies on indentation for setting the levels in the hierarchy.

[Paragraph]
In the following example you can see how there are 3 different levels. One with starting at the left of the text and another level with two rows starting at the same column, defining the node A. At the end there is one more level where the text is indented further than the previous lines defining the nodes B and C.

[Code]
mindmap
    Root
        A
            B
            C

[Paragraph]
In summary is a simple text outline where there is one node at the root level called Root which has one child A. A in turn has two children Band C. In the diagram below we can see this rendered as a mindmap.

[Code]
Root

[Code]
A

[Code]
A

[Code]
B

[Code]
C

[Code]


[Paragraph]
In this way we can use a text outline to generate a hierarchical mindmap.

[Paragraph]
Mermaid mindmaps can show nodes using different shapes. When specifying a shape for a node the syntax is similar to flowchart nodes, with an id followed by the shape definition and with the text within the shape delimiters. Where possible we try/will try to keep the same shapes as for flowcharts, even though they are not all supported from the start.

[Paragraph]
Mindmap can show the following shapes:

[Code]


[Code]


[Code]


[Code]


[Code]


[Code]


[Code]


[Paragraph]
More shapes will be added, beginning with the shapes available in flowcharts.

[Paragraph]
As with flowcharts you can add icons to your nodes but with an updated syntax. The styling for the font based icons are added during the integration so that they are available for the web page. This is not something a diagram author can do but has to be done with the site administrator or the integrator. Once the icon fonts are in place you add them to the mind map nodes using the ::icon() syntax. You place the classes for the icon within the parenthesis like in the following example where icons for material design and Font Awesome 5 are displayed. The intention is that this approach should be used for all diagrams supporting icons. Experimental feature: This wider scope is also the reason Mindmaps are experimental as this syntax and approach could change.

[Code]
::icon()

[Code]


[Paragraph]
Again the syntax for adding classes is similar to flowcharts. You can add classes using a triple colon following a number of css classes separated by space. In the following example one of the nodes has two custom classes attached urgent turning the background red and the text white and large increasing the font size:

[Code]


[Paragraph]
These classes need to be supplied by the site administrator.

[Paragraph]
The actual indentation does not really matter only compared with the previous rows. If we take the previous example and disrupt it a little we can see how the calculations are performed. Let us start with placing C with a smaller indentation than B but larger then A.

[Code]
B

[Code]
A

[Code]
mindmap
    Root
        A
            B
          C

[Paragraph]
This outline is unclear as B clearly is a child of A but when we move on to C the clarity is lost. C is neither a child of B with a higher indentation nor does it have the same indentation as B. The only thing that is clear is that the first node with smaller indentation, indicating a parent, is A. Then Mermaid relies on this known truth and compensates for the unclear indentation and selects A as a parent of C leading till the same diagram with B and C as siblings.

[Code]
B

[Code]
A

[Code]
C

[Code]
C

[Code]
B

[Code]
B

[Code]
A

[Code]
C

[Code]
B

[Code]
C

[Code]


[Paragraph]
The "Markdown Strings" feature enhances mind maps by offering a more versatile string type, which supports text formatting options such as bold and italics, and automatically wraps text within labels.

[Code]


[Paragraph]
Formatting:

[Paragraph]
Mindmap uses the experimental lazy loading & async rendering features which could change in the future. From version 9.4.0 this diagram is included in mermaid but use lazy loading in order to keep the size of mermaid down. This is important in order to be able to add additional diagrams going forward.

[Paragraph]
You can still use the pre 9.4.0 method to add mermaid with mindmaps to a web page:

[Code]
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.esm.min.mjs';
  import mindmap from 'https://cdn.jsdelivr.net/npm/@mermaid-js/mermaid-mindmap@9.3.0/dist/mermaid-mindmap.esm.min.mjs';
  await mermaid.registerExternalDiagrams([mindmap]);
</script>

[Paragraph]
From version 9.4.0 you can simplify this code to:

[Code]
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
</script>

[Paragraph]
You can also refer the implementation in the live editor to see how the async loading is done.



---  Page (https://mermaid.js.org/syntax/timeline.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
Timeline: This is an experimental diagram for now. The syntax and properties can change in future releases. The syntax is stable except for the icon integration which is the experimental part.

[Paragraph]
"A timeline is a type of diagram used to illustrate a chronology of events, dates, or periods of time. It is usually presented graphically to indicate the passing of time, and it is usually organized chronologically. A basic timeline presents a list of events in chronological order, usually using dates as markers. A timeline can also be used to show the relationship between events, such as the relationship between the events of a person's life" (Wikipedia).

[Code]
timeline
    title History of Social Media Platform
    2002 : LinkedIn
    2004 : Facebook
         : Google
    2005 : YouTube
    2006 : Twitter

[Paragraph]
The syntax for creating Timeline diagram is simple. You always start with the timeline keyword to let mermaid know that you want to create a timeline diagram.

[Code]
timeline

[Paragraph]
After that there is a possibility to add a title to the timeline. This is done by adding a line with the keyword title followed by the title text.

[Code]
title

[Paragraph]
Then you add the timeline data, where you always start with a time period, followed by a colon and then the text for the event. Optionally you can add a second colon and then the text for the event. So, you can have one or more events per time period.

[Code]
{time period} : {event}

[Paragraph]
or

[Code]
{time period} : {event} : {event}

[Paragraph]
or

[Code]
{time period} : {event}
              : {event}
              : {event}

[Paragraph]
NOTE: Both time period and event are simple text, and not limited to numbers.

[Paragraph]
Let us look at the syntax for the example above.

[Code]
timeline
    title History of Social Media Platform
    2002 : LinkedIn
    2004 : Facebook : Google
    2005 : YouTube
    2006 : Twitter

[Paragraph]
In this way we can use a text outline to generate a timeline diagram. The sequence of time period and events is important, as it will be used to draw the timeline. The first time period will be placed at the left side of the timeline, and the last time period will be placed at the right side of the timeline.

[Paragraph]
Similarly, the first event will be placed at the top for that specific time period, and the last event will be placed at the bottom.

[Paragraph]
You can group time periods in sections/ages. This is done by adding a line with the keyword section followed by the section name.

[Code]
section

[Paragraph]
All subsequent time periods will be placed in this section until a new section is defined.

[Paragraph]
If no section is defined, all time periods will be placed in the default section.

[Paragraph]
Let us look at an example, where we have grouped the time periods in sections.

[Code]
timeline
    title Timeline of Industrial Revolution
    section 17th-20th century
        Industry 1.0 : Machinery, Water power, Steam <br>power
        Industry 2.0 : Electricity, Internal combustion engine, Mass production
        Industry 3.0 : Electronics, Computers, Automation
    section 21st century
        Industry 4.0 : Internet, Robotics, Internet of Things
        Industry 5.0 : Artificial intelligence, Big data, 3D printing

[Paragraph]
As you can see, the time periods are placed in the sections, and the sections are placed in the order they are defined.

[Paragraph]
All time periods and events under a given section follow a similar color scheme. This is done to make it easier to see the relationship between time periods and events.

[Paragraph]
By default, the text for time-periods and events will be wrapped if it is too long. This is done to avoid that the text is drawn outside the diagram.

[Paragraph]
You can also use <br> to force a line break.

[Code]
<br>

[Paragraph]
Let us look at another example, where we have a long time period, and a long event.

[Code]
timeline
        title England's History Timeline
        section Stone Age
          7600 BC : Britain's oldest known house was built in Orkney, Scotland
          6000 BC : Sea levels rise and Britain becomes an island.<br> The people who live here are hunter-gatherers.
        section Bronze Age
          2300 BC : People arrive from Europe and settle in Britain. <br>They bring farming and metalworking.
                  : New styles of pottery and ways of burying the dead appear.
          2200 BC : The last major building works are completed at Stonehenge.<br> People now bury their dead in stone circles.
                  : The first metal objects are made in Britain.Some other nice things happen. it is a good time to be alive.

[Code]
timeline
        title MermaidChart 2023 Timeline
        section 2023 Q1 <br> Release Personal Tier
          Bullet 1 : sub-point 1a : sub-point 1b
               : sub-point 1c
          Bullet 2 : sub-point 2a : sub-point 2b
        section 2023 Q2 <br> Release XYZ Tier
          Bullet 3 : sub-point <br> 3a : sub-point 3b
               : sub-point 3c
          Bullet 4 : sub-point 4a : sub-point 4b

[Paragraph]
As explained earlier, each section has a color scheme, and each time period and event under a section follow the similar color scheme.

[Paragraph]
However, if there is no section defined, then we have two possibilities:

[Code]
timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter

[Paragraph]
NOTE: that there are no sections defined, and each time period and its corresponding events will have its own color scheme.

[Code]
disableMultiColor

[Paragraph]
You will need to add this option either via mermaid.initialize function or directives.

[Code]
mermaid.initialize({
        theme: 'base',
        startOnLoad: true,
        logLevel: 0,
        timeline: {
          disableMulticolor: false,
        },
        ...
        ...

[Paragraph]
let us look at same example, where we have disabled the multiColor option.

[Code]
---
config:
  logLevel: 'debug'
  theme: 'base'
  timeline:
    disableMulticolor: true
---
    timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter

[Paragraph]
You can customize the color scheme using the cScale0 to cScale11 theme variables, which will change the background colors. Mermaid allows you to set unique colors for up-to 12 sections, where cScale0 variable will drive the value of the first section or time-period, cScale1 will drive the value of the second section and so on. In case you have more than 12 sections, the color scheme will start to repeat.

[Code]
cScale0

[Code]
cScale11

[Code]
cScale0

[Code]
cScale1

[Paragraph]
If you also want to change the foreground color of a section, you can do so use theme variables corresponding cScaleLabel0 to cScaleLabel11 variables.

[Code]
cScaleLabel0

[Code]
cScaleLabel11

[Paragraph]
NOTE: Default values for these theme variables are picked from the selected theme. If you want to override the default values, you can use the initialize call to add your custom theme variable values.

[Code]
initialize

[Paragraph]
Example:

[Paragraph]
Now let's override the default values for the cScale0 to cScale2 variables:

[Code]
cScale0

[Code]
cScale2

[Code]
---
config:
  logLevel: 'debug'
  theme: 'default'
  themeVariables:
    cScale0: '#ff0000'
    cScaleLabel0: '#ffffff'
    cScale1: '#00ff00'
    cScale2: '#0000ff'
    cScaleLabel2: '#ffffff'
---
       timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter
          2007 : Tumblr
          2008 : Instagram
          2010 : Pinterest

[Paragraph]
See how the colors are changed to the values specified in the theme variables.

[Paragraph]
Mermaid supports a bunch of pre-defined themes which you can use to find the right one for you. PS: you can actually override an existing theme's variable to get your own custom theme going. Learn more about theming your diagram.

[Paragraph]
The following are the different pre-defined theme options:

[Code]
base

[Code]
forest

[Code]
dark

[Code]
default

[Code]
neutral

[Paragraph]
NOTE: To change theme you can either use the initialize call or directives. Learn more about directives Let's put them to use, and see how our sample diagram looks in different themes:

[Code]
initialize

[Code]
---
config:
  logLevel: 'debug'
  theme: 'base'
---
    timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter
          2007 : Tumblr
          2008 : Instagram
          2010 : Pinterest

[Code]
---
config:
  logLevel: 'debug'
  theme: 'forest'
---
    timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter
          2007 : Tumblr
          2008 : Instagram
          2010 : Pinterest

[Code]
---
config:
  logLevel: 'debug'
  theme: 'dark'
---
    timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter
          2007 : Tumblr
          2008 : Instagram
          2010 : Pinterest

[Code]
---
config:
  logLevel: 'debug'
  theme: 'default'
---
    timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter
          2007 : Tumblr
          2008 : Instagram
          2010 : Pinterest

[Code]
---
config:
  logLevel: 'debug'
  theme: 'neutral'
---
    timeline
        title History of Social Media Platform
          2002 : LinkedIn
          2004 : Facebook : Google
          2005 : YouTube
          2006 : Twitter
          2007 : Tumblr
          2008 : Instagram
          2010 : Pinterest

[Paragraph]
Timeline uses experimental lazy loading & async rendering features which could change in the future.The lazy loading is important in order to be able to add additional diagrams going forward.

[Paragraph]
You can use this method to add mermaid including the timeline diagram to a web page:

[Code]
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
</script>

[Paragraph]
You can also refer the implementation in the live editor to see how the async loading is done.



---  Page (https://mermaid.js.org/syntax/zenuml.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A Sequence diagram is an interaction diagram that shows how processes operate with one another and in what order.

[Paragraph]
Mermaid can render sequence diagrams with ZenUML. Note that ZenUML uses a different syntax than the original Sequence Diagram in mermaid.

[Code]
zenuml
    title Demo
    Alice->John: Hello John, how are you?
    John->Alice: Great!
    Alice->John: See you later!

[Paragraph]
The participants can be defined implicitly as in the first example on this page. The participants or actors are rendered in order of appearance in the diagram source text. Sometimes you might want to show the participants in a different order than how they appear in the first message. It is possible to specify the actor's order of appearance by doing the following:

[Code]
zenuml
    title Declare participant (optional)
    Bob
    Alice
    Alice->Bob: Hi Bob
    Bob->Alice: Hi Alice

[Paragraph]
If you specifically want to use symbols instead of just rectangles with text you can do so by using the annotator syntax to declare participants as per below.

[Code]
zenuml
    title Annotators
    @Actor Alice
    @Database Bob
    Alice->Bob: Hi Bob
    Bob->Alice: Hi Alice

[Paragraph]
Here are the available annotators:

[Paragraph]
The participants can have a convenient identifier and a descriptive label.

[Code]
zenuml
    title Aliases
    A as Alice
    J as John
    A->J: Hello John, how are you?
    J->A: Great!

[Paragraph]
Messages can be one of:

[Paragraph]
You can think of a sync (blocking) method in a programming language.

[Code]
zenuml
    title Sync message
    A.SyncMessage
    A.SyncMessage(with, parameters) {
      B.nestedSyncMessage()
    }

[Paragraph]
You can think of an async (non-blocking) method in a programming language. Fire an event and forget about it.

[Code]
zenuml
    title Async message
    Alice->Bob: How are you?

[Paragraph]
We use new keyword to create an object.

[Code]
new

[Code]
zenuml
    new A1
    new A2(with, parameters)

[Paragraph]
There are three ways to express a reply message:

[Code]
zenuml
    // 1. assign a variable from a sync message.
    a = A.SyncMessage()

    // 1.1. optionally give the variable a type
    SomeType a = A.SyncMessage()

    // 2. use return keyword
    A.SyncMessage() {
    return result
    }

    // 3. use @return or @reply annotator on an async message
    @return
    A->B: result

[Paragraph]
The third way @return is rarely used, but it is useful when you want to return to one level up.

[Code]
@return

[Code]
zenuml
    title Reply message
    Client->A.method() {
      B.method() {
        if(condition) {
          return x1
          // return early
          @return
          A->Client: x11
        }
      }
      return x2
    }

[Paragraph]
Sync messages and Creation messages are naturally nestable with {}.

[Code]
{}

[Code]
zenuml
    A.method() {
      B.nested_sync_method()
      B->C: nested async message
    }

[Paragraph]
It is possible to add comments to a sequence diagram with // comment syntax. Comments will be rendered above the messages or fragments. Comments on other places are ignored. Markdown is supported.

[Code]
// comment

[Paragraph]
See the example below:

[Code]
zenuml
    // a comment on a participant will not be rendered
    BookService
    // a comment on a message.
    // **Markdown** is supported.
    BookService.getBook()

[Paragraph]
It is possible to express loops in a ZenUML diagram. This is done by any of the following notations:

[Code]
while(condition) {
    ...statements...
}

[Paragraph]
See the example below:

[Code]
zenuml
    Alice->John: Hello John, how are you?
    while(true) {
      John->Alice: Great!
    }

[Paragraph]
It is possible to express alternative paths in a sequence diagram. This is done by the notation

[Code]
if(condition1) {
    ...statements...
} else if(condition2) {
    ...statements...
} else {
    ...statements...
}

[Paragraph]
See the example below:

[Code]
zenuml
    Alice->Bob: Hello Bob, how are you?
    if(is_sick) {
      Bob->Alice: Not so good :(
    } else {
      Bob->Alice: Feeling fresh like a daisy
    }

[Paragraph]
It is possible to render an opt fragment. This is done by the notation

[Code]
opt

[Code]
opt {
  ...statements...
}

[Paragraph]
See the example below:

[Code]
zenuml
    Alice->Bob: Hello Bob, how are you?
    Bob->Alice: Not so good :(
    opt {
      Bob->Alice: Thanks for asking
    }

[Paragraph]
It is possible to show actions that are happening in parallel.

[Paragraph]
This is done by the notation

[Code]
par {
  statement1
  statement2
  statement3
}

[Paragraph]
See the example below:

[Code]
zenuml
    par {
        Alice->Bob: Hello guys!
        Alice->John: Hello guys!
    }

[Paragraph]
It is possible to indicate a stop of the sequence within the flow (usually used to model exceptions).

[Paragraph]
This is done by the notation

[Code]
try {
  ...statements...
} catch {
  ...statements...
} finally {
  ...statements...
}

[Paragraph]
See the example below:

[Code]
zenuml
    try {
      Consumer->API: Book something
      API->BookingService: Start booking process
    } catch {
      API->Consumer: show failure
    } finally {
      API->BookingService: rollback status
    }

[Paragraph]
Zenuml uses the experimental lazy loading & async rendering features which could change in the future.

[Paragraph]
You can use this method to add mermaid including the zenuml diagram to a web page:

[Code]
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  import zenuml from 'https://cdn.jsdelivr.net/npm/@mermaid-js/mermaid-zenuml@0.1.0/dist/mermaid-zenuml.esm.min.mjs';
  await mermaid.registerExternalDiagrams([zenuml]);
</script>



---  Page (https://mermaid.js.org/syntax/sankey.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A sankey diagram is a visualization used to depict a flow from one set of values to another.

[Paragraph]
WARNING

[Paragraph]
This is an experimental diagram. Its syntax are very close to plain CSV, but it is to be extended in the nearest future.

[Paragraph]
The things being connected are called nodes and the connections are called links.

[Paragraph]
This example taken from observable. It may be rendered a little bit differently, though, in terms of size and colors.

[Code]
---
config:
  sankey:
    showValues: false
---
sankey-beta

Agricultural 'waste',Bio-conversion,124.729
Bio-conversion,Liquid,0.597
Bio-conversion,Losses,26.862
Bio-conversion,Solid,280.322
Bio-conversion,Gas,81.144
Biofuel imports,Liquid,35
Biomass imports,Solid,35
Coal imports,Coal,11.606
Coal reserves,Coal,63.965
Coal,Solid,75.571
District heating,Industry,10.639
District heating,Heating and cooling - commercial,22.505
District heating,Heating and cooling - homes,46.184
Electricity grid,Over generation / exports,104.453
Electricity grid,Heating and cooling - homes,113.726
Electricity grid,H2 conversion,27.14
Electricity grid,Industry,342.165
Electricity grid,Road transport,37.797
Electricity grid,Agriculture,4.412
Electricity grid,Heating and cooling - commercial,40.858
Electricity grid,Losses,56.691
Electricity grid,Rail transport,7.863
Electricity grid,Lighting & appliances - commercial,90.008
Electricity grid,Lighting & appliances - homes,93.494
Gas imports,Ngas,40.719
Gas reserves,Ngas,82.233
Gas,Heating and cooling - commercial,0.129
Gas,Losses,1.401
Gas,Thermal generation,151.891
Gas,Agriculture,2.096
Gas,Industry,48.58
Geothermal,Electricity grid,7.013
H2 conversion,H2,20.897
H2 conversion,Losses,6.242
H2,Road transport,20.897
Hydro,Electricity grid,6.995
Liquid,Industry,121.066
Liquid,International shipping,128.69
Liquid,Road transport,135.835
Liquid,Domestic aviation,14.458
Liquid,International aviation,206.267
Liquid,Agriculture,3.64
Liquid,National navigation,33.218
Liquid,Rail transport,4.413
Marine algae,Bio-conversion,4.375
Ngas,Gas,122.952
Nuclear,Thermal generation,839.978
Oil imports,Oil,504.287
Oil reserves,Oil,107.703
Oil,Liquid,611.99
Other waste,Solid,56.587
Other waste,Bio-conversion,77.81
Pumped heat,Heating and cooling - homes,193.026
Pumped heat,Heating and cooling - commercial,70.672
Solar PV,Electricity grid,59.901
Solar Thermal,Heating and cooling - homes,19.263
Solar,Solar Thermal,19.263
Solar,Solar PV,59.901
Solid,Agriculture,0.882
Solid,Thermal generation,400.12
Solid,Industry,46.477
Thermal generation,Electricity grid,525.531
Thermal generation,Losses,787.129
Thermal generation,District heating,79.329
Tidal,Electricity grid,9.452
UK land based bioenergy,Bio-conversion,182.01
Wave,Electricity grid,19.013
Wind,Electricity grid,289.366

[Paragraph]
The idea behind syntax is that a user types sankey-beta keyword first, then pastes raw CSV below and get the result.

[Code]
sankey-beta

[Paragraph]
It implements CSV standard as described here with subtle differences:

[Paragraph]
It is implied that 3 columns inside CSV should represent source, target and value accordingly:

[Code]
source

[Code]
target

[Code]
value

[Code]
sankey-beta

%% source,target,value
Electricity grid,Over generation / exports,104.453
Electricity grid,Heating and cooling - homes,113.726
Electricity grid,H2 conversion,27.14

[Paragraph]
CSV does not support empty lines without comma delimiters by default. But you can add them if needed:

[Code]
sankey-beta

Bio-conversion,Losses,26.862

Bio-conversion,Solid,280.322

Bio-conversion,Gas,81.144

[Paragraph]
If you need to have a comma, wrap it in double quotes:

[Code]
sankey-beta

Pumped heat,"Heating and cooling, homes",193.026
Pumped heat,"Heating and cooling, commercial",70.672

[Paragraph]
If you need to have double quote, put a pair of them inside quoted string:

[Code]
sankey-beta

Pumped heat,"Heating and cooling, ""homes""",193.026
Pumped heat,"Heating and cooling, ""commercial""",70.672

[Paragraph]
You can customize link colors, node alignments and diagram dimensions.

[Code]
<script>
  const config = {
    startOnLoad: true,
    securityLevel: 'loose',
    sankey: {
      width: 800,
      height: 400,
      linkColor: 'source',
      nodeAlignment: 'left',
    },
  };
  mermaid.initialize(config);
</script>

[Paragraph]
You can adjust links' color by setting linkColor to one of those:

[Code]
linkColor

[Code]
source

[Code]
target

[Code]
gradient

[Code]
#a1a1a1

[Paragraph]
Graph layout can be changed by setting nodeAlignment to:

[Code]
nodeAlignment

[Code]
justify

[Code]
center

[Code]
left

[Code]
right



---  Page (https://mermaid.js.org/syntax/xyChart.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
In the context of mermaid-js, the XY chart is a comprehensive charting module that encompasses various types of charts that utilize both x-axis and y-axis for data representation. Presently, it includes two fundamental chart types: the bar chart and the line chart. These charts are designed to visually display and analyze data that involve two numerical variables.

[Paragraph]
It's important to note that while the current implementation of mermaid-js includes these two chart types, the framework is designed to be dynamic and adaptable. Therefore, it has the capacity for expansion and the inclusion of additional chart types in the future. This means that users can expect an evolving suite of charting options within the XY chart module, catering to various data visualization needs as new chart types are introduced over time.

[Code]
xychart-beta
    title "Sales Revenue"
    x-axis [jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec]
    y-axis "Revenue (in $)" 4000 --> 11000
    bar [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000]
    line [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000]

[Paragraph]
INFO

[Paragraph]
All text values that contain only one word can be written without ". If a text value has many words in it, specifically if it contains spaces, enclose the value in "

[Code]
"

[Code]
"

[Paragraph]
The chart can be drawn horizontal or vertical, default value is vertical.

[Code]
xychart-beta horizontal
...

[Paragraph]
The title is a short description of the chart and it will always render on top of the chart.

[Code]
xychart-beta
    title "This is a simple example"
    ...

[Paragraph]
INFO

[Paragraph]
If the title is a single word one no need to use ", but if it has space " is needed

[Code]
"

[Code]
"

[Paragraph]
The x-axis primarily serves as a categorical value, although it can also function as a numeric range value when needed.

[Code]
x-axis title min --> max

[Code]
x-axis "title with space" [cat1, "cat2 with space", cat3]

[Paragraph]
The y-axis is employed to represent numerical range values, it cannot have categorical values.

[Code]
y-axis title min --> max

[Code]
y-axis title

[Paragraph]
INFO

[Paragraph]
Both x and y axis are optional if not provided we will try to create the range

[Paragraph]
A line chart offers the capability to graphically depict lines.

[Code]
line [2.3, 45, .98, -3.4]

[Paragraph]
A bar chart offers the capability to graphically depict bars.

[Code]
bar [2.3, 45, .98, -3.4]

[Paragraph]
The only two things required are the chart name (xychart-beta) and one data set. So you will be able to draw a chart with a simple config like

[Code]
xychart-beta

[Code]
xychart-beta
    line [+1.3, .6, 2.4, -.34]

[Paragraph]
Themes for xychart resides inside xychart attribute so to set the variables use this syntax:

[Code]
---
config:
  themeVariables:
    xyChart:
      titleColor: '#ff0000'
---

[Code]
---
config:
    xyChart:
        width: 900
        height: 600
        showDataLabel: true
    themeVariables:
        xyChart:
            titleColor: "#ff0000"
---
xychart-beta
    title "Sales Revenue"
    x-axis [jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec]
    y-axis "Revenue (in $)" 4000 --> 11000
    bar [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000]
    line [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000]



---  Page (https://mermaid.js.org/syntax/block.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Code]
block-beta
columns 1
  db(("DB"))
  blockArrowId6<["&nbsp;&nbsp;&nbsp;"]>(down)
  block:ID
    A
    B["A wide one in the middle"]
    C
  end
  space
  D
  ID --> D
  C --> D
  style B fill:#969,stroke:#333,stroke-width:4px

[Paragraph]
Block diagrams are an intuitive and efficient way to represent complex systems, processes, or architectures visually. They are composed of blocks and connectors, where blocks represent the fundamental components or functions, and connectors show the relationship or flow between these components. This method of diagramming is essential in various fields such as engineering, software development, and process management.

[Paragraph]
The primary purpose of block diagrams is to provide a high-level view of a system, allowing for easy understanding and analysis without delving into the intricate details of each component. This makes them particularly useful for simplifying complex systems and for explaining the overall structure and interaction of components within a system.

[Paragraph]
Many people use mermaid flowcharts for this purpose. A side-effect of this is that the automatic layout sometimes move shapes to positions that the diagram maker does not want. Block diagrams use a different approach. In this diagram we give the author full control over where the shapes are positioned.

[Paragraph]
Block diagrams have a wide range of applications across various industries and disciplines. Some of the key use cases include:

[Paragraph]
Software Architecture: In software development, block diagrams can be used to illustrate the architecture of a software application. This includes showing how different modules or services interact, data flow, and high-level component interaction.

[Paragraph]
Network Diagrams: Block diagrams are ideal for representing network architectures in IT and telecommunications. They can depict how different network devices and services are interconnected, including routers, switches, firewalls, and the flow of data across the network.

[Paragraph]
Process Flowcharts: In business and manufacturing, block diagrams can be employed to create process flowcharts. These flowcharts represent various stages of a business or manufacturing process, helping to visualize the sequence of steps, decision points, and the flow of control.

[Paragraph]
Electrical Systems: Engineers use block diagrams to represent electrical systems and circuitry. They can illustrate the high-level structure of an electrical system, the interaction between different electrical components, and the flow of electrical currents.

[Paragraph]
Educational Purposes: Block diagrams are also extensively used in educational materials to explain complex concepts and systems in a simplified manner. They help in breaking down and visualizing scientific theories, engineering principles, and technological systems.

[Paragraph]
These examples demonstrate the versatility of block diagrams in providing clear and concise representations of complex systems. Their simplicity and clarity make them a valuable tool for professionals across various fields to communicate complex ideas effectively.

[Paragraph]
In the following sections, we will delve into the specifics of creating and manipulating block diagrams using Mermaid, covering everything from basic syntax to advanced configurations and styling.

[Paragraph]
Creating block diagrams with Mermaid is straightforward and accessible. This section introduces the basic syntax and structure needed to start building simple diagrams. Understanding these foundational concepts is key to efficiently utilizing Mermaid for more complex diagramming tasks.

[Paragraph]
At its core, a block diagram consists of blocks representing different entities or components. In Mermaid, these blocks are easily created using simple text labels. The most basic form of a block diagram can be a series of blocks without any connectors.

[Paragraph]
Example - Simple Block Diagram: To create a simple block diagram with three blocks labeled 'a', 'b', and 'c', the syntax is as follows:

[Code]
block-beta
  a b c

[Paragraph]
This example will produce a horizontal sequence of three blocks. Each block is automatically spaced and aligned for optimal readability.

[Paragraph]
While simple block diagrams are linear and straightforward, more complex systems may require a structured layout. Mermaid allows for the organization of blocks into multiple columns, facilitating the creation of more intricate and detailed diagrams.

[Paragraph]
Example - Multi-Column Diagram: In scenarios where you need to distribute blocks across multiple columns, you can specify the number of columns and arrange the blocks accordingly. Here's how to create a block diagram with three columns and four blocks, where the fourth block appears in a second row:

[Code]
block-beta
  columns 3
  a b c d

[Paragraph]
This syntax instructs Mermaid to arrange the blocks 'a', 'b', 'c', and 'd' across three columns, wrapping to the next row as needed. This feature is particularly useful for representing layered or multi-tiered systems, such as network layers or hierarchical structures.

[Paragraph]
These basic building blocks of Mermaid's block diagrams provide a foundation for more complex diagramming. The simplicity of the syntax allows for quick creation and iteration of diagrams, making it an efficient tool for visualizing ideas and concepts. In the next section, we'll explore advanced block configuration options, including setting block widths and creating composite blocks.

[Paragraph]
Building upon the basics, this section delves into more advanced features of block diagramming in Mermaid. These features allow for greater flexibility and complexity in diagram design, accommodating a wider range of use cases and scenarios.

[Paragraph]
In more complex diagrams, you may need blocks that span multiple columns to emphasize certain components or to represent larger entities. Mermaid allows for the adjustment of block widths to cover multiple columns, enhancing the diagram's readability and structure.

[Paragraph]
Example - Block Spanning Multiple Columns: To create a block diagram where one block spans across two columns, you can specify the desired width for each block:

[Code]
block-beta
  columns 3
  a["A label"] b:2 c:2 d

[Paragraph]
In this example, the block labeled "A labels" spans one column, while blocks 'b', 'c' span 2 columns, and 'd' is again allocated its own column. This flexibility in block sizing is crucial for accurately representing systems with components of varying significance or size.

[Paragraph]
Composite blocks, or blocks within blocks, are an advanced feature in Mermaid's block diagram syntax. They allow for the representation of nested or hierarchical systems, where one component encompasses several subcomponents.

[Paragraph]
Example - Composite Blocks: Creating a composite block involves defining a parent block and then nesting other blocks within it. Here's how to define a composite block with nested elements:

[Code]
block-beta
    block
      D
    end
    A["A: I am a wide one"]

[Paragraph]
In this syntax, 'D' is a nested block within a larger parent block. This feature is particularly useful for depicting complex structures, such as a server with multiple services or a department within a larger organizational framework.

[Paragraph]
Mermaid also allows for dynamic adjustment of column widths based on the content of the blocks. The width of the columns is determined by the widest block in the column, ensuring that the diagram remains balanced and readable.

[Paragraph]
Example - Dynamic Column Widths: In diagrams with varying block sizes, Mermaid automatically adjusts the column widths to fit the largest block in each column. Here's an example:

[Code]
block-beta
  columns 3
  a:3
  block:group1:2
    columns 2
    h i j k
  end
  g
  block:group2:3
    %% columns auto (default)
    l m n o p q r
  end

[Paragraph]
This example demonstrates how Mermaid dynamically adjusts the width of the columns to accommodate the widest block, in this case, 'a' and the composite block 'e'. This dynamic adjustment is essential for creating visually balanced and easy-to-understand diagrams.

[Paragraph]
Merging Blocks Horizontally: In scenarios where you need to stack blocks horizontally, you can use column width to accomplish the task. Blocks can be arranged vertically by putting them in a single column. Here is how you can create a block diagram in which 4 blocks are stacked on top of each other:

[Code]
block-beta
  block
    columns 1
    a["A label"] b c d
  end

[Paragraph]
In this example, the width of the merged block dynamically adjusts to the width of the largest child block.

[Paragraph]
With these advanced configuration options, Mermaid's block diagrams can be tailored to represent a wide array of complex systems and structures. The flexibility offered by these features enables users to create diagrams that are both informative and visually appealing. In the following sections, we will explore further capabilities, including different block shapes and linking options.

[Paragraph]
Mermaid's block diagrams are not limited to standard rectangular shapes. A variety of block shapes are available, allowing for a more nuanced and tailored representation of different types of information or entities. This section outlines the different block shapes you can use in Mermaid and their specific applications.

[Paragraph]
Mermaid supports a range of block shapes to suit different diagramming needs, from basic geometric shapes to more specialized forms.

[Paragraph]
To create a block with round edges, which can be used to represent a softer or more flexible component:

[Code]
block-beta
    id1("This is the text in the box")

[Paragraph]
A stadium-shaped block, resembling an elongated circle, can be used for components that are process-oriented:

[Code]
block-beta
    id1(["This is the text in the box"])

[Paragraph]
For representing subroutines or contained processes, a block with double vertical lines is useful:

[Code]
block-beta
    id1[["This is the text in the box"]]

[Paragraph]
The cylindrical shape is ideal for representing databases or storage components:

[Code]
block-beta
    id1[("Database")]

[Paragraph]
A circle can be used for centralized or pivotal components:

[Code]
block-beta
    id1(("This is the text in the circle"))

[Paragraph]
For decision points, use a rhombus, and for unique or specialized processes, asymmetric and hexagon shapes can be utilized:

[Paragraph]
Asymmetric

[Code]
block-beta
  id1>"This is the text in the box"]

[Paragraph]
Rhombus

[Code]
block-beta
    id1{"This is the text in the box"}

[Paragraph]
Hexagon

[Code]
block-beta
    id1{{"This is the text in the box"}}

[Paragraph]
Parallelogram and trapezoid shapes are perfect for inputs/outputs and transitional processes:

[Code]
block-beta
  id1[/"This is the text in the box"/]
  id2[\"This is the text in the box"\]
  A[/"Christmas"\]
  B[\"Go shopping"/]

[Paragraph]
For highlighting critical or high-priority components, a double circle can be effective:

[Code]
block-beta
    id1((("This is the text in the circle")))

[Paragraph]
Mermaid also offers unique shapes like block arrows and space blocks for directional flow and spacing.

[Paragraph]
Block arrows can visually indicate direction or flow within a process:

[Code]
block-beta
  blockArrowId<["Label"]>(right)
  blockArrowId2<["Label"]>(left)
  blockArrowId3<["Label"]>(up)
  blockArrowId4<["Label"]>(down)
  blockArrowId5<["Label"]>(x)
  blockArrowId6<["Label"]>(y)
  blockArrowId6<["Label"]>(x, down)

[Paragraph]
Space blocks can be used to create intentional empty spaces in the diagram, which is useful for layout and readability:

[Code]
block-beta
  columns 3
  a space b
  c   d   e

[Paragraph]
or

[Code]
block-beta
  ida space:3 idb idc

[Paragraph]
Note that you can set how many columns the space block occupied using the number notation space:num where num is a number indicating the num columns width. You can also use space which defaults to one column.

[Code]
space:num

[Code]
space

[Paragraph]
The variety of shapes and special blocks in Mermaid enhances the expressive power of block diagrams, allowing for more accurate and context-specific representations. These options give users the flexibility to create diagrams that are both informative and visually appealing. In the next sections, we will explore the ways to connect these blocks and customize their appearance.

[Paragraph]
Discuss the various shapes available for blocks, including standard shapes and special forms like block arrows and space blocks.

[Paragraph]
One of the key features of block diagrams in Mermaid is the ability to connect blocks using various types of edges or links. This section explores the different ways blocks can be interconnected to represent relationships and flows between components.

[Paragraph]
The most fundamental aspect of connecting blocks is the use of arrows or links. These connectors depict the relationships or the flow of information between the blocks. Mermaid offers a range of arrow types to suit different diagramming needs.

[Paragraph]
Example - Basic Links

[Paragraph]
A simple link with an arrow can be created to show direction or flow from one block to another:

[Code]
block-beta
  A space B
  A-->B

[Paragraph]
This example illustrates a direct connection from block 'A' to block 'B', using a straightforward arrow.

[Paragraph]
This syntax creates a line connecting 'A' and 'B', implying a relationship or connection without indicating a specific direction.

[Paragraph]
In addition to connecting blocks, it's often necessary to describe or label the relationship. Mermaid allows for the inclusion of text on links, providing context to the connections.

[Paragraph]
Example - Text with Links To add text to a link, the syntax includes the text within the link definition:

[Code]
block-beta
  A space:2 B
  A-- "X" -->B

[Paragraph]
This example show how to add descriptive text to the links, enhancing the information conveyed by the diagram.

[Paragraph]
Example - Edges and Styles:

[Code]
block-beta
columns 1
  db(("DB"))
  blockArrowId6<["&nbsp;&nbsp;&nbsp;"]>(down)
  block:ID
    A
    B["A wide one in the middle"]
    C
  end
  space
  D
  ID --> D
  C --> D
  style B fill:#939,stroke:#333,stroke-width:4px

[Paragraph]
Beyond the structure and layout of block diagrams, Mermaid offers extensive styling options. These customization features allow for the creation of more visually distinctive and informative diagrams. This section covers how to apply individual styles to blocks and how to use classes for consistent styling across multiple elements.

[Paragraph]
Mermaid enables detailed styling of individual blocks, allowing you to apply various CSS properties such as color, stroke, and border thickness. This feature is especially useful for highlighting specific parts of a diagram or for adhering to certain visual themes.

[Paragraph]
To apply custom styles to a block, you can use the style keyword followed by the block identifier and the desired CSS properties:

[Code]
style

[Code]
block-beta
  id1 space id2
  id1("Start")-->id2("Stop")
  style id1 fill:#636,stroke:#333,stroke-width:4px
  style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5

[Paragraph]
Mermaid enables applying styling to classes, which could make styling easier if you want to apply a certain set of styles to multiple elements, as you could just link those elements to a class.

[Code]
block-beta
  A space B
  A-->B
  classDef blue fill:#6e6ce6,stroke:#333,stroke-width:4px;
  class A blue
  style B fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5

[Paragraph]
In this example, a class named 'blue' is defined and applied to block 'A', while block 'B' receives individual styling. This demonstrates the flexibility of Mermaid in applying both shared and unique styles within the same diagram.

[Paragraph]
The ability to style blocks individually or through classes provides a powerful tool for enhancing the visual impact and clarity of block diagrams. Whether emphasizing certain elements or maintaining a cohesive design across the diagram, these styling capabilities are central to effective diagramming. The next sections will present practical examples and use cases, followed by tips for troubleshooting common issues.

[Paragraph]
The versatility of Mermaid's block diagrams becomes evident when applied to real-world scenarios. This section provides practical examples demonstrating the application of various features discussed in previous sections. These examples showcase how block diagrams can be used to represent complex systems and processes in an accessible and informative manner.

[Paragraph]
Combining the elements of structure, linking, and styling, we can create comprehensive diagrams that serve specific purposes in different contexts.

[Paragraph]
Illustrating a simple software system architecture with interconnected components:

[Code]
block-beta
  columns 3
  Frontend blockArrowId6<[" "]>(right) Backend
  space:2 down<[" "]>(down)
  Disk left<[" "]>(left) Database[("Database")]

  classDef front fill:#696,stroke:#333;
  classDef back fill:#969,stroke:#333;
  class Frontend front
  class Backend,Database back

[Paragraph]
This example shows a basic architecture with a frontend, backend, and database. The blocks are styled to differentiate between types of components.

[Paragraph]
Representing a business process flow with decision points and multiple stages:

[Code]
block-beta
  columns 3
  Start(("Start")) space:2
  down<[" "]>(down) space:2
  Decision{{"Make Decision"}} right<["Yes"]>(right) Process1["Process A"]
  downAgain<["No"]>(down) space r3<["Done"]>(down)
  Process2["Process B"] r2<["Done"]>(right) End(("End"))

  style Start fill:#969;
  style End fill:#696;

[Paragraph]
These practical examples and scenarios underscore the utility of Mermaid block diagrams in simplifying and effectively communicating complex information across various domains.

[Paragraph]
The next section, 'Troubleshooting and Common Issues', will provide insights into resolving common challenges encountered when working with Mermaid block diagrams, ensuring a smooth diagramming experience.

[Paragraph]
Working with Mermaid block diagrams can sometimes present challenges, especially as the complexity of the diagrams increases. This section aims to provide guidance on resolving common issues and offers tips for managing more intricate diagram structures.

[Paragraph]
Understanding and avoiding common syntax errors is key to a smooth experience with Mermaid diagrams.

[Paragraph]
A common mistake is incorrect linking syntax, which can lead to unexpected results or broken diagrams:

[Code]
block-beta
  A - B

[Paragraph]
Correction: Ensure that links between blocks are correctly specified with arrows (--> or ---) to define the direction and type of connection. Also remember that one of the fundamentals for block diagram is to give the author full control of where the boxes are positioned so in the example you need to add a space between the boxes:

[Code]
block-beta
  A space B
  A --> B

[Paragraph]
Applying styles in the wrong context or with incorrect syntax can lead to blocks not being styled as intended:

[Code]
block-beta
    A
    style A fill#969;

[Paragraph]
Correction: Correct the syntax by ensuring proper separation of style properties with commas and using the correct CSS property format:

[Code]
block-beta
  A
  style A fill:#969,stroke:#333;

[Paragraph]
Managing complexity in Mermaid diagrams involves planning and employing best practices.

[Paragraph]
Break down complex diagrams into smaller, more manageable components. This approach not only makes the diagram easier to understand but also simplifies the creation and maintenance process.

[Paragraph]
Use classes to maintain consistent styling across similar elements. This not only saves time but also ensures a cohesive and professional appearance.

[Paragraph]
Use comments with %% within the Mermaid syntax to document the purpose of various parts of the diagram. This practice is invaluable for maintaining clarity, especially when working in teams or returning to a diagram after some time.

[Code]
%%

[Paragraph]
With these troubleshooting tips and best practices, you can effectively manage and resolve common issues in Mermaid block diagrams. The final section, 'Conclusion', will summarize the key points covered in this documentation and invite user feedback for continuous improvement.



---  Page (https://mermaid.js.org/syntax/packet.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A packet diagram is a visual representation used to illustrate the structure and contents of a network packet. Network packets are the fundamental units of data transferred over a network.

[Paragraph]
This diagram type is particularly useful for developers, network engineers, educators, and students who require a clear and concise way to represent the structure of network packets.

[Code]
packet-beta
start: "Block name" %% Single-bit block
start-end: "Block name" %% Multi-bit blocks
... More Fields ...

[Paragraph]
Using start and end bit counts can be difficult, especially when modifying a design. For this we add a bit count field, which starts from the end of the previous field automagically. Use +<count> to set the number of bits, thus:

[Code]
+<count>

[Code]
packet-beta
+1: "Block name" %% Single-bit block
+8: "Block name" %% 8-bit block
9-15: "Manually set start and end, it's fine to mix and match"
... More Fields ...

[Code]
---
title: "TCP Packet"
---
packet-beta
0-15: "Source Port"
16-31: "Destination Port"
32-63: "Sequence Number"
64-95: "Acknowledgment Number"
96-99: "Data Offset"
100-105: "Reserved"
106: "URG"
107: "ACK"
108: "PSH"
109: "RST"
110: "SYN"
111: "FIN"
112-127: "Window"
128-143: "Checksum"
144-159: "Urgent Pointer"
160-191: "(Options and Padding)"
192-255: "Data (variable length)"

[Code]
packet-beta
title UDP Packet
+16: "Source Port"
+16: "Destination Port"
32-47: "Length"
48-63: "Checksum"
64-95: "Data (variable length)"

[Code]
0-15

[Paragraph]
Please refer to the configuration guide for details.



---  Page (https://mermaid.js.org/syntax/kanban.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
Mermaid’s Kanban diagram allows you to create visual representations of tasks moving through different stages of a workflow. This guide explains how to use the Kanban diagram syntax, based on the provided example.

[Paragraph]
A Kanban diagram in Mermaid starts with the kanban keyword, followed by the definition of columns (stages) and tasks within those columns.

[Code]


[Paragraph]
Columns represent the different stages in your workflow, such as “Todo,” “In Progress,” “Done,” etc. Each column is defined using a unique identifier and a title enclosed in square brackets.

[Paragraph]
Syntax:

[Code]
columnId[Column Title]

[Paragraph]
Like this id1[Todo]

[Code]
id1[Todo]

[Paragraph]
Tasks are listed under their respective columns with an indentation. Each task also has a unique identifier and a description enclosed in square brackets.

[Paragraph]
Syntax:

[Code]
taskId[Task Description]

[Code]
•	taskId: A unique identifier for the task.
•	[Task Description]: The description of the task.

[Paragraph]
Example:

[Code]
docs[Create Documentation]

[Paragraph]
You can include additional metadata for each task using the @{ ... } syntax. Metadata can contain key-value pairs like assigned, ticket, priority, etc. This will be rendered added to the rendering of the node.

[Code]
•	assigned: Specifies who is responsible for the task.
•	ticket: Links the task to a ticket or issue number.
•	priority: Indicates the urgency of the task. Allowed values: 'Very High', 'High', 'Low' and 'Very Low'

[Code]


[Paragraph]
You can customize the Kanban diagram using a configuration block at the beginning of your markdown file. This is useful for setting global settings like a base URL for tickets. Currently there is one configuration option for kanban diagrams ticketBaseUrl. This can be set as in the following example:

[Code]
ticketBaseUrl

[Code]
---
config:
  kanban:
    ticketBaseUrl: 'https://yourproject.atlassian.net/browse/#TICKET#'
---

[Paragraph]
When the kanban item has an assigned ticket number the ticket number in the diagram will have a link to an external system where the ticket is defined. The ticketBaseUrl sets the base URL to the external system and #TICKET# is replaced with the ticket value from task metadata to create a valid link.

[Code]
ticketBaseUrl

[Paragraph]
Below is the full Kanban diagram based on the provided example:

[Code]


[Paragraph]
In conclusion, creating a Kanban diagram in Mermaid is a straightforward process that effectively visualizes your workflow. Start by using the kanban keyword to initiate the diagram. Define your columns with unique identifiers and titles to represent different stages of your project. Under each column, list your tasks—also with unique identifiers—and provide detailed descriptions as needed. Remember that proper indentation is crucial; tasks must be indented under their parent columns to maintain the correct structure.

[Paragraph]
You can enhance your diagram by adding optional metadata to tasks using the @{ ... } syntax, which allows you to include additional context such as assignee, ticket numbers, and priority levels. For further customization, utilize the configuration block at the top of your file to set global options like ticketBaseUrl for linking tickets directly from your diagram.

[Paragraph]
By adhering to these guidelines—ensuring unique identifiers, proper indentation, and utilizing metadata and configuration options—you can create a comprehensive and customized Kanban board that effectively maps out your project’s workflow using Mermaid.



---  Page (https://mermaid.js.org/syntax/architecture.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
In the context of mermaid-js, the architecture diagram is used to show the relationship between services and resources commonly found within the Cloud or CI/CD deployments. In an architecture diagram, services (nodes) are connected by edges. Related services can be placed within groups to better illustrate how they are organized.

[Code]
architecture-beta
    group api(cloud)[API]

    service db(database)[Database] in api
    service disk1(disk)[Storage] in api
    service disk2(disk)[Storage] in api
    service server(server)[Server] in api

    db:L -- R:server
    disk1:T -- B:server
    disk2:T -- B:db

[Paragraph]
The building blocks of an architecture are groups, services, edges, and junctions.

[Code]
groups

[Code]
services

[Code]
edges

[Code]
junctions

[Paragraph]
For supporting components, icons are declared by surrounding the icon name with (), while labels are declared by surrounding the text with [].

[Code]
()

[Code]
[]

[Paragraph]
To begin an architecture diagram, use the keyword architecture-beta, followed by your groups, services, edges, and junctions. While each of the 3 building blocks can be declared in any order, care must be taken to ensure the identifier was previously declared by another component.

[Code]
architecture-beta

[Paragraph]
The syntax for declaring a group is:

[Code]
group {group id}({icon name})[{title}] (in {parent id})?

[Paragraph]
Put together:

[Code]
group public_api(cloud)[Public API]

[Paragraph]
creates a group identified as public_api, uses the icon cloud, and has the label Public API.

[Code]
public_api

[Code]
cloud

[Code]
Public API

[Paragraph]
Additionally, groups can be placed within a group using the optional in keyword

[Code]
in

[Code]
group private_api(cloud)[Private API] in public_api

[Paragraph]
The syntax for declaring a service is:

[Code]
service {service id}({icon name})[{title}] (in {parent id})?

[Paragraph]
Put together:

[Code]
service database1(database)[My Database]

[Paragraph]
creates the service identified as database1, using the icon database, with the label My Database.

[Code]
database1

[Code]
database

[Code]
My Database

[Paragraph]
If the service belongs to a group, it can be placed inside it through the optional in keyword

[Code]
in

[Code]
service database1(database)[My Database] in private_api

[Paragraph]
The syntax for declaring an edge is:

[Code]
{serviceId}{{group}}?:{T|B|L|R} {<}?--{>}? {T|B|L|R}:{serviceId}{{group}}?

[Paragraph]
The side of the service the edge comes out of is specified by adding a colon (:) to the side of the service connecting to the arrow and adding L|R|T|B

[Code]
:

[Code]
L|R|T|B

[Paragraph]
For example:

[Code]
db:R -- L:server

[Paragraph]
creates an edge between the services db and server, with the edge coming out of the right of db and the left of server.

[Code]
db

[Code]
server

[Code]
db

[Code]
server

[Code]
db:T -- L:server

[Paragraph]
creates a 90 degree edge between the services db and server, with the edge coming out of the top of db and the left of server.

[Code]
db

[Code]
server

[Code]
db

[Code]
server

[Paragraph]
Arrows can be added to each side of an edge by adding < before the direction on the left, and/or > after the direction on the right.

[Code]
<

[Code]
>

[Paragraph]
For example:

[Code]
subnet:R --> L:gateway

[Paragraph]
creates an edge with the arrow going into the gateway service

[Code]
gateway

[Paragraph]
To have an edge go from a group to another group or service within another group, the {group} modifier can be added after the serviceId.

[Code]
{group}

[Code]
serviceId

[Paragraph]
For example:

[Code]
service server[Server] in groupOne
service subnet[Subnet] in groupTwo

server{group}:B --> T:subnet{group}

[Paragraph]
creates an edge going out of groupOne, adjacent to server, and into groupTwo, adjacent to subnet.

[Code]
groupOne

[Code]
server

[Code]
groupTwo

[Code]
subnet

[Paragraph]
It's important to note that groupIds cannot be used for specifying edges and the {group} modifier can only be used for services within a group.

[Code]
groupId

[Code]
{group}

[Paragraph]
Junctions are a special type of node which acts as a potential 4-way split between edges.

[Paragraph]
The syntax for declaring a junction is:

[Code]
junction {junction id} (in {parent id})?

[Code]
architecture-beta
    service left_disk(disk)[Disk]
    service top_disk(disk)[Disk]
    service bottom_disk(disk)[Disk]
    service top_gateway(internet)[Gateway]
    service bottom_gateway(internet)[Gateway]
    junction junctionCenter
    junction junctionRight

    left_disk:R -- L:junctionCenter
    top_disk:B -- T:junctionCenter
    bottom_disk:T -- B:junctionCenter
    junctionCenter:R -- L:junctionRight
    top_gateway:B -- T:junctionRight
    bottom_gateway:T -- B:junctionRight

[Paragraph]
By default, architecture diagram supports the following icons: cloud, database, disk, internet, server. Users can use any of the 200,000+ icons available in iconify.design, or add custom icons.

[Code]
cloud

[Code]
database

[Code]
disk

[Code]
internet

[Code]
server

[Paragraph]
After the icons are installed, they can be used in the architecture diagram by using the format "name:icon-name", where name is the value used when registering the icon pack.

[Code]
architecture-beta
    group api(logos:aws-lambda)[API]

    service db(logos:aws-aurora)[Database] in api
    service disk1(logos:aws-glacier)[Storage] in api
    service disk2(logos:aws-s3)[Storage] in api
    service server(logos:aws-ec2)[Server] in api

    db:L -- R:server
    disk1:T -- B:server
    disk2:T -- B:db



---  Page (https://mermaid.js.org/syntax/radar.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
A radar diagram is a simple way to plot low-dimensional data in a circular format.

[Paragraph]
It is also known as a radar chart, spider chart, star chart, cobweb chart, polar chart, or Kiviat diagram.

[Paragraph]
This diagram type is particularly useful for developers, data scientists, and engineers who require a clear and concise way to represent data in a circular format.

[Paragraph]
It is commonly used to graphically summarize and compare the performance of multiple entities across multiple dimensions.

[Code]
radar-beta
axis A, B, C, D, E
curve c1{1,2,3,4,5}
curve c2{5,4,3,2,1}
... More Fields ...

[Code]
---
title: "Grades"
---
radar-beta
  axis m["Math"], s["Science"], e["English"]
  axis h["History"], g["Geography"], a["Art"]
  curve a["Alice"]{85, 90, 80, 70, 75, 90}
  curve b["Bob"]{70, 75, 85, 80, 90, 85}

  max 100
  min 0

[Code]
radar-beta
  title Restaurant Comparison
  axis food["Food Quality"], service["Service"], price["Price"]
  axis ambiance["Ambiance"],

  curve a["Restaurant A"]{4, 3, 2, 4}
  curve b["Restaurant B"]{3, 4, 3, 3}
  curve c["Restaurant C"]{2, 3, 4, 2}
  curve d["Restaurant D"]{2, 2, 4, 3}

  graticule polygon
  max 5

[Paragraph]
title: The title is an optional field that allows to render a title at the top of the radar diagram.

[Code]
title

[Code]
radar-beta
  title Title of the Radar Diagram
  ...

[Paragraph]
axis: The axis keyword is used to define the axes of the radar diagram.

[Code]
axis

[Paragraph]
Each axis is represented by an ID and an optional label.

[Paragraph]
Multiple axes can be defined in a single line.

[Code]
radar-beta
  axis id1["Label1"]
  axis id2["Label2"], id3["Label3"]
  ...

[Paragraph]
curve: The curve keyword is used to define the data points for a curve in the radar diagram.

[Code]
curve

[Paragraph]
Each curve is represented by an ID, an optional label, and a list of values.

[Paragraph]
Values can be defined by a list of numbers or a list of key-value pairs. If key-value pairs are used, the key represents the axis ID and the value represents the data point. Else, the data points are assumed to be in the order of the axes defined.

[Paragraph]
Multiple curves can be defined in a single line.

[Code]
radar-beta
  axis axis1, axis2, axis3
  curve id1["Label1"]{1, 2, 3}
  curve id2["Label2"]{4, 5, 6}, id3{7, 8, 9}
  curve id4{ axis3: 30, axis1: 20, axis2: 10 }
  ...

[Code]
showLegend

[Code]
max

[Code]
min

[Code]
0

[Code]
graticule

[Code]
circle

[Code]
polygon

[Code]
circle

[Code]
ticks

[Code]
5

[Code]
radar-beta
  ...
  showLegend true
  max 100
  min 0
  graticule circle
  ticks 5
  ...

[Paragraph]
Please refer to the configuration guide for details.

[Code]
600

[Code]
600

[Code]
50

[Code]
50

[Code]
50

[Code]
50

[Code]
1

[Code]
1.05

[Code]
0.17

[Paragraph]
INFO

[Paragraph]
The default values for these variables depend on the theme used. To override the default values, set the desired values in the themeVariables section of the configuration:

[Paragraph]
config: themeVariables: cScale0: "#FF0000" cScale1: "#00FF00"

[Paragraph]
Radar charts support the color scales cScale${i} where i is a number from 0 to the theme's maximum number of colors in its color scale. Usually, the maximum number of colors is 12.

[Code]
cScale${i}

[Code]
i

[Code]
0

[Code]
12

[Paragraph]
INFO

[Paragraph]
Specific variables for radar resides inside the radar key. To set the radar style options, use this syntax.

[Code]
radar

[Paragraph]
config: themeVariables: radar: axisColor: "#FF0000"

[Code]
black

[Code]
1

[Code]
12px

[Code]
0.7

[Code]
2

[Code]
black

[Code]
0.5

[Code]
1

[Code]
10

[Code]
14px

[Code]
---
config:
  radar:
    axisScaleFactor: 0.25
    curveTension: 0.1
  theme: base
  themeVariables:
    cScale0: "#FF0000"
    cScale1: "#00FF00"
    cScale2: "#0000FF"
    radar:
      curveOpacity: 0
---
radar-beta
  axis A, B, C, D, E
  curve c1{1,2,3,4,5}
  curve c2{5,4,3,2,1}
  curve c3{3,3,3,3,3}



---  Page (https://mermaid.js.org/syntax/examples.html) ---

[Paragraph]
Customize your layout and design in Mermaid Chart’s visual editor!
Try now

[Paragraph]
This page contains a collection of examples of diagrams and charts that can be created through mermaid and its myriad applications.

[Paragraph]
If you wish to learn how to support mermaid on your webpage, read the Beginner's Guide.

[Paragraph]
If you wish to learn about mermaid's syntax, Read the Diagram Syntax section.

[Code]


[Code]


[Code]


[Code]


[Code]


[Code]


[Code]


[Code]


[Code]




